[{"content":"Search Engine Architecture The architecture is based off of a 2001 paper (Searching the Web) by Arasu et al. published by the Association for Computing Machinery\nA schematic describing different components of the search engine design (from Arasu et al.)\nCrawler(s) and Crawl Control The crawler(s) browse(s) the web for the search engine, similar to how a human would follow links to reach different pages. The crawler starts at a specific root URL and starts the recursive process of extracting hyperlinks crawling these additional webpages. The crawler caches each retrieved page into a page repository. The crawler will continue visiting webpages until local resources are exhausted (i.e. no more storage in the page repository.\nIndexer Module The indexer module extracts all of the words from each page, and records the URL where the word occurred. This process creates a large lookup table which provides all of the URLs that point to pages where a given word occurs. Furthermore, the indexer also keeps track of the number of occurences per page, allowing for tracking pages with a large number of keywords on the single page.\nQuerier Engine Module This module is responsible for receiving and fulfilling search requests from users. It uses the page indexes to get a list of URLs which contain the keywords in the query. Then the module ranks pages based on the number of occurrences of keywords in the user query.\nImplementation See GitHub Repository for the source code.\nCrawler Implementation In this implementation, we use a single crawler to browse the webpages. The implementation is a standalone program which crawls the web starting from the seed url, fetches links from webpages continuing to a certain depth, and then caches these webpages in a specific page directory. The crawler ignores duplicate webpages when it scans each page for URLs. Furthermore, it has guardrails in-place to prevent it from crawling the entirety of the web (we don\u0026rsquo;t want to crawl pages that didn\u0026rsquo;t give us permission ;) )\nUsage:\n$ ./crawler seedURL pageDirectory maxDepth Here we see the verbose output of the program:\nThe Crawler in Action\nIndexer Implementation The indexer module produces an index file which stores the lookup table mapping each keyword to their host URLs with the number of ocurrences. It browses the page directory created by the crawler and uses this directory to construct the index. The module uses one main data structure: an index structure which maps from word to (docID, #occurences) pairs. The documentID is a unique ID for each webpage cached in the pageDirectory.\nUsage:\n./indexer pageDirectory indexFilename Querier Implementation The querier module is another standalone program which returns a page ranking according to a user\u0026rsquo;s query in stdin. To use the querier program, it simply requires the index file (created by the indexer program) and the page directory (created by the crawler program). It reads the index file into memory as an index data structure. The program parses each query and uses the union and intersection keywords (\u0026lsquo;AND\u0026rsquo; vs \u0026lsquo;OR\u0026rsquo;) in the query and uses the index to return a ranked list of URLs based on each score.\nUsage:\n./querier pageDirectory indexFilename Querier in Action\n","permalink":"https://srbarton43.github.io/projects/tse/","summary":"A simple search engine written in C","title":"Tiny Search Engine"},{"content":"About For my digital electronics class, my lab partner and I designed an MIDI controller for the Basys3 FPGA board. The FPGA was programed using VHDL. The controller acts as a receiver for the serial MIDI signal coming through over UART and does Direct Digital Synthesis (DDS) to output an analog sine wave. We both learned a lot about digital design and spent many hours debugging on an oscilliscope.\nDemonstration Source Code Link to Repository Design A High-Level Block Diagram of the System\nBefore we even started thinking about writing HDL code for the board, there were many iterations of designs on paper. Here I will go over the design of each subcomponent in the system:\nClock_gen The Clock_Gen component generates a 1 MHz clock signal using the hardware clock which runs at 100 MHz. This system clock frequency was chosen according to the recommended specifications of the PMOD DA2 component. The maximum clock speed for the DA2 is 30 MHz, and the 1 MHz clock fits well into these specifications.\nRTL Block Diagram for the Clock_gen subcomponent\nMIDI_Receiver The MIDI receiver takes the 10-bit serial data from the port MIDI_in, synchronizes it to the specified baud rate, and provides parallel out an 8-bit data_out signal to pipe into the datapath. Internally, it uses a shift register to store each bit serially, and asserts a signal once all the entire MIDI message byte has been received.\nRTL Block Diagram for the MIDI_Receiver component\nDatapath The datapath receives bytes of data from the MIDI receiver one byte at a time, and stores these bytes in specified registers according to their type, whether it be a status byte, pitch byte, or a velocity byte. The datapath processes this data, and passes the necessary information to the DDS and DAC components.\nRTL Block Diagram for the Datapath component\nDDS The Direct Digital Synthesis component converts the m value (derived from the MIDI pitch number) and outputs a sine wave at the correct frequency. The sample rate is approx. 44.1 kHz (de-facto 43.8kHz), typical for cd-quality audio. The sine wave amplitudes are sampled from a BROM lookup table which was provided by Xilinx. A counter which counts by m each time specifies the output frequency (higher m means a higher frequency).\nRTL Block Diagram for the DDS component\nDAC_interface The DAC Interface controls communication from the FPGA to the external PMOD DA2 component. It is a serial peripheral interface (SPI). It consists of a parallel to serial shift register and a controller. The controller asserts CS’ to the external DAC. The specific digital to analog protocol used in this design is 16 bits in big-endian with four leading zeroes.\nRTL Block Diagram for the DAC_interface component\nFinal Report Previous Next \u0026nbsp; \u0026nbsp; / [pdf] View the PDF file here. ","permalink":"https://srbarton43.github.io/projects/midicontroller/","summary":"A MIDI controller built from scratch on FPGA written in VHDL","title":"Midi Controller"},{"content":"Modules Here we list the various modules in our yalnix implementation… each module has its own header file, and a well-defined API.\nkernel The kernel module stores all code necessary for booting yalnix, and other necessary procedures. The two important functions are KernelStart and SetKernelBrk. KernelStart initializes all important kernel data structures and initializes virtual memory for the system. SetKernelBrk is called each time the kernel must resize its heap, and allocates free frames accordingly.\nkernel_utils The kernel_utils module provides methods to print the user context, the doIdle function, KernelContext switching and copying. It also has a heap checker which we used in debugging, as well as yalnix_xalloc, for memory allocation checkers that would TracePrint and abort if there was an issue allocating memory in the kernel. We also have helper functions to check if an address is in region 1 and if it is readable/writeable by the user, which is used for checking buffer addresses for syscalls.\npagetable The pagetable module stores all functions and routines involving pagetables and pagetable entries (PTEs). The module abstracts all access away from accessing raw PTE elements, so allows writing safer code throughout the program.\nbitvector The bitvector module allows for an abstract representation for tracking free memory frames. Each free frame of memory is represented by a ‘0’ on the bitvector and a ‘1’ means that the frame is mapped to virtual memory. For the machines that we used, there were typically 512 frames of physical memory available, but the size of the bitvector is dynamically determined by bootstrapping inside KernelStart\nlinked_list The linked_list module is an implementation of a linked list data structure and is used throughout Yalnix for creating queues and other lists. It provides several queue-specific functions such as dequeue and peek and is generally used as a FIFO list. We wrapped linked list functions in all other list/queue function calls in other modules so that there was less repetition of code throughout the project, and so that it was easier to isolate bugs to one module.\npcb The pcb module implements the process control block data structure used in our kernel. We initially wrote it to have be its own linked list node, but because we want to keep a linked list of children we decided that each pcb should be its own structure that has pcb_node types pointing to it (so we also implement wrapper functions / structures for pcb_lists off of the linked_list module). The pcb_t struct is transparent to the user, but it also has methods for dealing with pcb lists, dealing with the process’s child list, creating new and retiring processes, and getting processes from queues.\nprog_mgmt The proc_mgmt module contains methods and global structures for process management. The currently running process and process queues are global variables from this module, as well as methods to initialize the Idle and Init PCBs. It also has methods to help with sleeping processes and switching processes. We implemented our round-robin scheduling algorithm in this module, in which the kernel will switch to the first process off the ready queue (or go to idle if there are no processes ready). We also have methods for blocking the current process and unblocking the process (which takes in a flag for if it’s in the blocked queue or stored in another bookkeeping structure, like a pipe, cvar, lock, etc.).\nLoadProgram This module allows for programs specifically compiled for Yalnix to be loaded into kernel memory. The backbone for this module was mostly written for us, but we added specific implementation details such as how we handled pagetables and bookkeeping for PCBs.\ntrap The trap module implements the traps the hardware can throw to Yalnix.\ntrap_clock will decrement the timer on sleeping processes, and then perform a round-robin process switch if there are any ready processes. trap_kernel will, through a switch case, call the syscalls described in the syscalls module. trap_memory will handle access errors and map errors. In the case of an access error, the process will be killed, and in the case of a map error, if the offending address is below the stack and above the red zone, the stack will grow to meet it, otherwise the process will be killed. trap_illegal will kill the current process (user error) trap_math will kill the current process (user error) trap_tty_transmit will unblock the process that is waiting on a given TTY terminal to finish transmitting. trap_tty_receive will receive the bytes from a tty input into the tty buffer (described in tty module) and unblock the process currently waiting to receive input from that terminal (if there is one). If there are more bytes to receive than there is space in the receiving buffer, the buffer will double in size until there is space. (So the tty terminal could fill up the kernel memory if there are enough inputs into the buffer that are not read or flushed by a program). trap_unimplemented will TracePrint at level 1 if the interrupt vector table somehow throws a trap that we can’t handle. syscalls The syscalls module contains code to handle each of the 21 Yalnix syscalls on the kernel end of the OS. Each time a user program calls a syscall, the hardware throws a TRAP_KERNEL and executes one of the syscalls according to the UserContext provided, will call the appropriate kernel syscall handler. Syscalls return integer return codes like -1 for ERROR and 0 for success, but also integer values when reading from / writing to buffers, described in the modules that contain our syscall logic below.\ntty The tty module describes structures and functions for handling tty input and output. There are buffers for tty output (tty_buf) and for input (tty_recv_buf). They both hold a pointer to an allocated buffer, a pointer to the end of the data in the buffer, and the length of the data in the buffer. Additionally, tty_recv_buf holds the size of the allocated buffer so that it can grow if necessary. There are also global arrays of pcbs and buffers for each tty_terminal (send and receive). There’s a tty_init method that KernelStart calls to initialize all the global arrays. When a user calls TtyWrite, the kernel (after trapping and calling the syscall) will allocate a buffer in the kernel, copy the data from the user buffer into the kernel buffer, and then write the maximum number of bytes to the tty terminal until the entire kernel buffer is finished (blocking each time and waiting for the trap_tty_transmit to unblock it), and then the number of bytes written in total will be returned. When a user calls TtyRead, the process will check to see if there are any bytes available in the kernel buffer (and block if there are not, waiting for the trap_tty_receive to unblock it), and then copy either the requested number of bytes or the number of available bytes from the kernel buffer into the user buffer, whichever is lesser, and return that number in the syscall. If the user reads fewer bytes than there are in the buffer, the kernel will shift the buffer to move the next-available bytes to the front of the buffer.\nWe also handle a number of bad / malicious inputs by returning -1 (defined ERROR) from the syscalls. If the TTY_id’s are bad, we return -1. If the buffer length is a negative integer, we return -1. If the user tries to pass in a buffer that is not in region 1, we return -1. TtyWrite is allowed to read from any buffers in user memory that are valid (including user text), because the user should be allowed to read their own text. However, TtyRead is not allowed to write tty input into buffers in user memory because the user should not be allowed to overwrite their own code. We also put a hard cap on how many bytes a buffer can be (in both tty and in pipe) of 0x4000 (defined in include/kernel.h), because we felt that there should be protection in the kernel from a user trying to allocate too big of a buffer for a pipe or tty_terminal. If a user tries to TtyRead or TtyWrite more than 0x4000 bytes in one go, they will get a return code of -1 (and no bytes will be written/read). If a user, through their keyboard / tty input, tries to input enough bytes such that the tty buffer will overflow to be more than 0x4000 bytes, it will stop saving bytes once the size is more than 0x4000. All of this behavior is tested in the test/tty_break.c described in the TESTING_README.md file, with the expectation of this final tty input overflow issue, because we were unable to test reading in so many bytes into the tty terminal using the -In \u0026lt;filename\u0026gt; argument. Replicate this by running ./yalnix -lk 3 -I0 test.in -x -W test/ttybreak_serious after creating a file test.in in your directory with more than 17kB of garbage data and see that the kernel aborts because the tty process aborts before our kernel can handle the input.\npipe The pipe module contains all data structures and functions necessary for Yalnix’s three IPC syscalls. Our implementation of pipes are doubly ended, meaning that if a process has a pipe, it can both write and read from it. Pipes are implemented in a similar way as TTY, meaning that the pipe data structures contain a pointer to a dynamically allocated buffer, a pointer to the start of the buffer (which is typically the same as the buffer except temporarily when reading from the pipe). There is also an integer that is the pipe ID and a pointer to a list of PCBs that might be waiting on that pipe. The user must call PipeInit on a pointer to an integer to assign that integer to the correct PipeID (which will always be a multiple of 3, for handling the Reclaim syscall that needs to differentiate pipe, cvar, and lock IDs) and will return 0 for SUCCESS and -1 for ERROR (errors cases described below). A user can write data to the pipe with PipeWrite, which will write the given length of bytes to the kernel buffer from the user buffer, and then return the length written (or ERROR if there is an error growing the pipe buffer, such as if it is more than the max buffer size defined in include/kernel.h, and then it will broadcast to any processes waiting on the pipe to wake up to try to read. A user can read data from the pipe with PipeRead, where it will block if there are no bytes to read (and add to a list of waiting processes), or copy the given or available number (whichever is less) from the kernel buffer to the user buffer, returning that length or ERROR if there are any errors (described below).\nWe also handle a number of bad / malicious inputs by returning -1 (defined ERROR) from the syscalls. If the PipeIDs are bad, we return -1. If the buffer length is a negative integer, we return -1. If the user tries to pass in a buffer that is not in region 1, we return -1. PipeWrite is allowed to read from any buffers in user memory that are valid (including user text), because the user should be allowed to read their own text. However, PipeRead is not allowed to write from the kernel pipe buffer into buffers in user memory because the user should not be allowed to overwrite their own code. We also put a hard cap on how many bytes a buffer can be (in both tty and in pipe) of 0x4000 (defined in include/kernel.h), because we felt that there should be protection in the kernel from a user trying to allocate too big of a buffer for a pipe or tty_terminal. If a user tries to PipeWrite more than 0x4000 bytes in one go, they will get a return code of -1 (and no bytes will be written/read). If a user tries to PipeWrite less than 0x4000 bytes but it will cause the pipe buffer to grow to be more than 0x4000 bytes, it will write the bytes that get it to be right at the max size and return that number of bytes, unless the buffer is exactly full, in which case it will return -1. All of this behavior is tested in the test/pipe_break.c described in the TESTING_README.md file.\nsync_vars The sync_vars module contains functions and data structures for all of the synchronization syscalls in Yalnix. There are both mutexes (lock_t) and conditional variable (cvar_t) data structures implemented in the module. The module also maintains a list of all locks and conditional variables stored in the kernel, and marks them each with a unique ID. We specifically implemented unique IDs between pipes, cvars, and locks based on the fact that we know there only need be three global lists, one for each data structure. Thus, each pipe has an id where pipe_id % 3 = 0, lock has an id where lock_id % 3 = 1, and cvar_id % 3 = 2. We made the specific implementation choice that if a process dies or is killed while holding a lock, it will release said lock. Also we made the design choice that a lock can only be reclaimed by a user program if it is not currently held by any process.\nSpecific Design Choices for Sync Vars\nlock_id % 3 = 1 and cvar_id % 3 = 2 (and pipe_id % 3 = 0) because we wanted Reclaim to be able to tell apart the different IDs when trying to call pipe_delete, etc., so this felt like a solution with the least overhead to be sure that lock, cvar, and pipe IDs are all exclusive. Processes release locks upon death to prevent deadlocks. Furthermore, if a process is queued to acquire the lock but then dies before acquiring it, it is skipped over in the queue for an alive process. Locks can only be reclaimed if they are currently unheld by a process. ","permalink":"https://srbarton43.github.io/projects/yalnix/","summary":"A slimmed down version of the Unix operating system","title":"Yalnix"},{"content":"About This project simulates four different computer hardware caching methods in software, using the LRU strategy to handle evictions. For a trace file with millions of lines, the program can simulate cache performance in under a second on an ubuntu VM.\nSource Code Link to Repository Available Cache Types direct-mapped two-way set-associative four-way set associative fully associative Verbose Output Direct-Mapped Caching in Verbose Mode\nFour-Way Set-Associative Caching in Verbose Mode\nComparing All Cache Types Four-Way Set-Associative Caching in Verbose Mode\n","permalink":"https://srbarton43.github.io/projects/cachesimulator/","summary":"A simulation of different types of memory caches","title":"Cache Simulator"},{"content":"Design The Nuggets game requires two standalone programs, the client and the server. We have further broken down these programs into smaller modules.\nClient The client acts in one of two modes:\nspectator, the passive spectator mode player, the interactive game-playing mode Functional decomposition into modules Simply a client module, handling all client functionality.\nMajor data structures client The client data structure holds all important values for the client as a global variable:\nnrows - stores number of rows in screen ncols - stores number of cols in screen justCollected - stores number of gold just picked up for status line purse - player purse for status line goldRemaining - number of nuggets remaining map - the string representation of the map playername - the name of player, null if spectator playerID - player\u0026rsquo;s id for status line hostname - hostname of server port - port of server Server Functional decomposition into modules The grid module keeps a 2-dimensional array of gridpoints, where each gridpoint stores information about what character it is (\u0026quot;.\u0026quot;, \u0026ldquo;#\u0026rdquo;, etc.), what player is on it (if applicable) and how much gold it contains. The game module keeps track of the game grid, along with an array of the players (and any spectators) that are in the game. As outlined above, each player stores its (row, column) position, purse size, playerID, and the portion of the game grid that is currently visible to him/her. Major data structures game The game module will exist within the server to hold a state of Nuggets as it is being played, complete with the current game grid, the players, spectator, and more.\nGrid - stores data about points across map of the game array of players - stores each of the players that are in the game lastPlayerNum - Array index of player last added spectator - stores unique spectator player data, if one exists player The player module will handle various aspects of players within the game. Its uses will include storing the regions of the grid visible to the player and formatting it for clients, tracking a player\u0026rsquo;s position and how much gold they have collected, storing their name for the leaderboard, and more.\nname - stores the player\u0026rsquo;s name playerID - the player\u0026rsquo;s unique character playerID 2d character array map - represents the portion of the grid visible to the player purse - stores amount of gold the player has row - stores the player\u0026rsquo;s row col - stores the player\u0026rsquo;s column address - player\u0026rsquo;s address in the network, so we can identify players as we receive client messages grid The grid will represent the data stored on the map and at each point on the map. The grid module loads a mapfile into the game\u0026rsquo;s memory, scatters gold across open rooms, and facilitates players\u0026rsquo; interaction with the map on the server\u0026rsquo;s end as they search for nuggets.\n2d array of gridpoints which store data about each point on the grid number of rows in the grid number of columns in the grid number of roomSpots in the grid number of gold pieces remaining in the grid Implementation The game was implemented in C, and uses the ncurses library in order to provide the text display (see https://github.com/srb-private-org/nuggets-game) .\nDiagram of Client/Server Implementation\nClient Data structures client: A global struct to track the size of client\u0026rsquo;s window, their status line in the game (which will either print the amount of gold they have or any error messages that come up), and the map that\u0026rsquo;s visible to them.\nstatic struct client { int nrows; int ncols; int justCollected; int purse; int goldRemaining; char* map; char* playername; char playerID; bool connected; char* hostname; char* port; } Definition of function prototypes A function to parse the command-line args, initialize the network:\nstatic void parseArgs(const int argc, char* argv[], char** hostname, char** port, char** playername); This function initializes the ncurses objects needed by the client, including the display.\nstatic void ncurses_init(); This function updates the display to correspond with the current state of the client.\nstatic void updateDisplay(const char* statusLine); This function is used in conjunction with message_loop to handle input.\nstatic bool handleInput(void* arg); This function sends the key input to the server.\nstatic bool sendKey(const addr_t to, int key); This function sends the player (or spectator) message to the server.\nstatic bool sendPlayMessage(const addr_t to, char* playerName); This function handles the message from server.\nstatic bool handleMessage(void* arg, const addr_t from, const char* message); This function handles the OK message.\nstatic bool handleOK(const char* message); This function handles the GRID message.\nstatic bool handleGrid(char* message); This function handles the GOLD message.\nstatic bool handleGold(char* message); This function handles the DISP message.\nstatic bool handleDisp(char* message); This function handles the QUIT message.\nstatic bool handleQuit(char* message); This function handles the ERROR message.\nstatic bool handleError(char* message); This function handles unrecognized messages.\nstatic bool handleUnrec(char* message); This function returns player status line.\nstatic char* getPlayerStatus(); This function returns spectator status line.\nstatic char* getSpectatorStatus(); Detailed pseudo code main: parse \u0026amp; validate command line args with parseArgs initialize log module form server address from args set ncurses (including the display) up with ncurses_init // do not init ncurses yet ; do so once we know we have received grid data from server, so we know we have a connection call sendPlayMessage with the playerName (which is null if the client is spectating) begin message_loop, passing display and functions for handling input and messages exit curses shut down communication with server parseArgs: if command line does not have two or three arguments exit nonzero if we cannot set an address to the given hostname and portnumber using message_setAddr exit nonzero ncurses_init: initialize the screen call cbreak call noecho create a new global struct client store the number of rows and columns on the screen in client's nrows and ncols set the color pair to yellow and black updateDisplay: print the status line at the top of screen print the map under the statusline call refresh to update the screen handleInput: set an adrr_t* to the void pointer passed in if that addr_t* is NULL print a message to stderr return true if that address is not a valid address print a message to stderr return true if the `connected` bool in client var hasn't been set to true log the error return true to exit set int c equal to the next keyboard press return sendKey of c sendKey: if the server passed in is NULL print an error message to log return true send message to server with form \u0026quot;KEY k\u0026quot; return false sendPlayMessage: if server is null print error message to stderr else if playerName is null send \u0026quot;SPECTATE\u0026quot; message to server else send message to server of form \u0026quot;PLAY (playerName) handleMessage: if server is null print error message to stderr return true if first word is OK call handleOK with messages else if first word is GRID return handleGrid with message else if first word is GOLD return handleGold with message else if first word is DISPLAY return handleDisp with message else if first word is QUIT return handleQuit with message else if first word is ERROR return handleError with message else return handleUnrec with mesaage handleOK: parse the player ID from the message and add it to the struct return false handleGrid: call ncurses_init() since we know we are now connected set the global client var's connected field to true parse nrows and ncols from the message while client struct's nrows and ncols are less than nrows + 1 and ncols, respectively print a window sizing message to log tell the user to enlarge the window and try again return false handleGold: parse number nuggets collected parse number nuggets in purse parse number nuggets still to be found update the client struct's statusLine with these values call updateDisplay on the client struct return false handleDisp: starting after the first newline character, parse grid display string from message set client struct's map equal to that string update the map with ncurses return false handleQuit: end curses parse the message text following the word \u0026quot;QUIT\u0026quot; into a string print this string to stdout followed by newline return true handleError: parse explanation into string write error message to log set client's status line equal to the text in the error message call updateDisplay return false handleUnrec: log error message with log.h since unhandled message return false getPlayerStatus: return formatted status line for player in memory getSpectatorStatus: return formatted status line for spectator in memory Server Data structures Game Data Structure This data structure will store info about the current game being played, including the game grid, an array containing slots for MaxPlayers (26) players in the game. Within the server module, game data will be stored globally so that it need not be passed to and validated by every function.\nstruct gameData { grid_t* grid; player_t* players[MaxPlayers]; player_t* spectator; int nextPlayerIndex; } Definition of function prototypes A function to parse \u0026amp; validate the command-line arguments and initialize the game struct\nstatic int parseArgs(const int argc, char* argv[]); A function to initialize the game data struct and the grid \u0026amp; player data therein.\nstatic void initializeGame(char* mapFile); A function to delete the game data and the grid and player data therein.\nstatic void gameData_delete(); A function to send the game\u0026rsquo;s grid dimensions to clients\nstatic void sendGridDimensions(const addr_t to); A function to send gold information to clients.\nstatic void sendGoldInfo(const addr_t to, int justCollected, int purse, int remaining); A function to send the current display to clients.\nstatic void sendDisplay(const addr_t to, char* stringifiedMap); A function to send QUIT messages with explanations to clients.\nstatic void sendQuit(const addr_t to, const char* explanation); A function for handling messages from the client\nstatic bool handleMessage(void* arg, const addr_t from, const char* message); A function to handle SPECTATE messages.\nstatic void handleSpectateMessage(const addr_t from); A function to handle PLAY messages.\nstatic void handlePlayMessage(const addr_t from, const char* message); A function to handle KEY keystroke messages.\nstatic bool handleKeyMessage(const addr_t from, const char* message); A function to handle movement key presses\nstatic bool handleMovementCase(const int rowChange, const int columnChange, player_t* player); A function to handle unrecognized messages.\nstatic void handleUnrecognizedMessage(addr_t to, const char* message); A function to get a player pointer from its address.\nstatic player_t* getPlayerFromAddress(addr_t address); A function to send error messages to clients\nstatic void sendError(addr_t to, const char* message); A function to send OK messages to clients\nstatic void sendOK(const addr_t to); A function to check if a line is blank\nstatic bool isBlankLine(const char* string); A function to format a player name.\nstatic void formatName(char* name); A function to convert a player\u0026rsquo;s index in the players array into an ID\nstatic inline char indexToPlayerID(const int index); A function to send a game over quit message to each player.\nstatic void gameOver(); A function to update each player\u0026rsquo;s map and send it to them\nstatic void sendUpdatedMaps(); Detailed pseudo code main start logging to stderr call parseArgs() with the given cmd line args start messages module, validate init call message_loop() with handleMessage, store result in bool call gameOver() call message_done() call log_done() call gameData_delete() return zero if message loop worked, otherwise nonzero parseArgs: validate commandline args if wrong number of args is given exit with proper usage message if seed provided verify it is a valid seed number seed the random-number generator with that seed else seed the random-number generator with getpid() verify map file can be opened for reading call initializeGame() with the validated map file name initializeGame allocate memory for global gameData variable call grid_loadMap with given mapFile call grid_placePiles on the map to scatter gold across the grid allocate space for MaxPlayers in game data set spectator pointer to null in game data set nextPlayerIndex to zero in game data handleMessage given a message and sender if the message matches \u0026quot;SPECTATE\u0026quot; call handleSpectateMessage() with sender address elif the message begins with \u0026quot;PLAY \u0026quot; call handlePlayMessage() with sender address and message elif the message begins with \u0026quot;KEY \u0026quot; call handleKeyMessage() with sender address and message return true to exit loop if key press resulted in game ending else call handleUnrecognizedMessage, with message return false sendGridDimensions get number of rows, cols stored in game data grid build string of form \u0026quot;GRID numberRows numberColumns\u0026quot; send the string to the given `to` address sendGoldInfo given positive ints justCollected, purse, remaining build string of form \u0026quot;GOLD justCollected purse remaining\u0026quot; send string to given `to` address sendDisplay given a player call player_mapToString with the player and game grid dimensions form the message \u0026quot;DISPLAY\\n\u0026quot; followed by the map string send the message to the player's address free the map string allocated in memory sendQuit send \u0026quot;QUIT \u0026quot; followed by given explanation to `to` address handleSpectateMessage if game's spectator is not NULL sendQuit with relevant explanation to old spectator's addr call player_delete on old spectator set spectator pointer in game data to NULL call player_new with null name, given `from` address, grid dimensions, (-1,-1) as row,col, true for isSpectator if we created the player without any issues store it in gameData spectator pointer call grid_updateSpectatorMap on the spectator with the game grid call sendGridDimensions to spectator's addr with game grid dimensions call sendGoldInfo to spectator address with justCollected = 0, purse = 0, and remaining gold in grid call sendDisplay with pointer to spectator handlePlayMessage if the game's nextPlayerIndex equals MaxPlayers call sendQuit to the new player, explaining that the game's full return store the given username in memory if isBlankLine() returns true for the username sendQuit to player with explanation free the username return call formatName on the username create a new player with player_new if we failed create the player free the username, log error, and return store the player at the nextPlayerIndex in gameData increment game data's nextPlayerIndex call grid_addPlayerRandom to place the player at random room spot in grid call grid_updatePlayerMap sendGridDimensions() to player sendGoldInfo() to palyer with justCollected = 0, purse = 0, and remaining gold sendDisplay() to player update spectator's and each player's map, send it to them handleKeyMessage parse next letter if we have more than a letter or no letter sendQuit, with explanation return false (don't exit message loop) call getPlayerFromAddress() with address to matching player pointer if we failed to find a match log the error return false take the key from the message switch with key char as conditional case Q call sendQuit, w/ explanation if the player pointer points to the same place as spectator sendQuit with \u0026quot;Thanks for watching!\u0026quot; call player_delete on spectator set spectator pointer to NULL else call grid_deletePlayer() sendQuit with \u0026quot;Thanks for playing!\u0026quot; // do NOT delete quit players - only spectator // we need to keep player data for the leaderboard! update player's maps with player gone send new map to each player update spectator map send new map to spectator return false (don't exit msg loop) cases (h, l, j, k, y, u, b, n) or any of their capitalized forms return handleMovementCase with the address, player, and key default case (invalid) call handleUnrecognizedMessage sendError with \u0026quot;unknown keystroke\u0026quot; return false handleMovementCase given from address, player, key pressed save the player's current purse value store the result of the player's attempt to move from grid_movePlayer if the player successfully moved if the player found gold get the remaining gold in the grid if there's no remaining gold return true (to exit message loop \u0026amp; trigger game over) else calculate gold just collected by subtracting old purse from new purse sendGoldInfo to player with just collected gold, new purse, remaining gold loop through player array if the player is not null sendGoldInfo to the player, with 0 just collected, their purse, gold remaining if we have a spectator sendGoldInfo, with 0 just collected, 0 purse, gold remaining loop through each player if the player's not null call grid_updatePlayerMap on the player with game's grid call sendDisplay to that player if we have a spectator call grid_updateSpectatorMap call sendDisplay to the specator return false handleUnrecognizedMessage log that we could not recognize message sendError send message of form \u0026quot;ERROR explanation\u0026quot; to client sendOK send message of form \u0026quot;OK k\u0026quot; to client, where k is a given char gameOver create special game over string to send, calculating buffer large enough to hold it loop through player array in game data if the player's not null add a single line to the game over string with their ID, purse, and name loop through player array in game data if the player is not null sendQuit to their address with the game over string if we have a spectator sendQuit to their address with game over string indexToPlayerID if the index is NOT within the range of 0..MaxPlayers return null character return 'A' + index given isBlankLine for each char in given string if isspace(char) does not return true return false return true formatName if the length of the name exceeds MaxNameLength set the character in the name string at MaxNameLength to be the terminating null char loop through index in name, until we hit its length if neither isgraph(char) and isblank(char) set that char in the string to be an underscore gameData_delete if the grid in the game data is null log error, exit program for each index in player array from [0..MaxPlayers) if the player's not null call player_delete on each player free player array's memory call player_delete on the spectator, if we have one call grid_delete on the grid stored in game data free global gameData's allocated memory getPlayerFromAddress if we cannot validate the address with message_isAddr return null player pointer if player array in game data is not null loop through each player if the player isn't null if message_eqAddr(given address, player address) return pointer to that player if we have a spectator if message_eqAddr(given address, spectator address) return pointer to the spectator return null sendUpdatedMaps for each player from 0 to MaxPlayers in gameData if the player is not null update player's map send it to them if the spectator in gameData isn't null update spectator's map send it to them Grid module The grid module allows us to construct and track a grid of gridpoints, where each gridpoint stores the amount of gold it has, what player is on it (if applicable), and what character the it should display. grid also provides several methods that interact with the player module, allowing the grid of gridpoints to be continually manipulated as players move around and collect gold.\nData structures gridpoint Stores the status of a given gridpoint in the grid. Will constantly be updated as players move onto gridpoints, off of gridpoints, and collect gold.\nstruct gridpoint{ int goldCount; char gridChar; player_t* player; } grid Stores a grid of gridpoints and the amount of gold remaining in these gridpoints, along with the grid\u0026rsquo;s number of rows and columns. This struct is a crucial part of Server\u0026rsquo;s game struct, as it stores the state of a given nuggets game.\nstruct grid{ gridpoint_t** gridpoints; int goldRemaining; int numRows; int numCols; int numRooms; } Definition of function prototypes A function to load a text file into a struct grid.\ngrid_t* grid_loadMap(char* fileName); A function to insert a player at a given position in a grid. Returns true if player was inserted, false otherwise.\nbool grid_addPlayer(grid_t* grid, player_t* player, int row, int col); A function to insert a player at a random room spot in the grid.\nvoid grid_addPlayerRandom(grid_t* grid, player_t* player); A function to delete a given player from a grid. Returns true if the player could be deleted, false otherwise.\nbool grid_deletePlayer(grid_t* grid, player_t* player); A function to generate an array of \u0026rsquo;num\u0026rsquo; pointers to 2-slot arrays representing random (row, column) room spot coordinates in the grid.\nint** grid_randomRoomSpots(grid_t* grid, int num); A function to place n piles of gold (where n is a randomly selected integer between min and max), containing a total of goldTotal gold pieces, at random room spots in a grid.\nvoid grid_placePiles(grid_t* grid, int min, int max, int goldTotal); A function to move a player by one unit in a given direction, then modify the player\u0026rsquo;s purse accordingly. Returns a status code based on the result of the move attempt. 0 = did not move, 1 = moved, 2 = moved and found gold, 3 = moved and hit other player\nint grid_movePlayer(grid_t* grid, player_t* player, char dxn); We use the following static local function to help implement grid_movePlayer.\nstatic int movePlayerHelper(grid_t* grid, player_t* player, int row change, int colChange); We use the following static local function to help implement the run feature within grid_movePlayer\nstatic int runHelper(grid_t* grid, player_t* player, int row change, int colChange); A function to add any gold at a player\u0026rsquo;s position to their purse. Returns true if gold is collected, and false if not.\nbool grid_collectGold(grid_t* grid, player_t* player); A function to tell us whether a given gridpoint is visible to a player.\nbool grid_isVisible(grid_t* grid, player_t* player, int row, int col); A static function to help us determine whether a gridpoint is visible if the line between it and a player is straight.\nstatic bool visibleHelperStraight(grid_t* grid, int playerRow, int playerCol, int row, int col); A static function to help us determine whether a player can see through an intersection.\nstatic bool intersectionHelper(grid_t* grid, double currentRow, double currentCol, bool isRowCheck) A function to modify a player\u0026rsquo;s map to reflect what they can currently see of the grid.\nvoid grid_updatePlayerMap(grid_t* grid, player_t* player); A function to update the spectator\u0026rsquo;s map to reflect the state of the game.\nvoid grid_updateSpectatorMap(grid_t* grid, player_t* spectator); A function to delete a grid.\nvoid grid_delete(grid_t* grid); Detailed pseudo code grid_loadMap: if the text file can be opened for reading create a new grid structure count the number of rows and columns in the text file passed into the function, add them to the grid structure as numRows and numCols create an empty array gridpoints of dimensions numRows * numCols allocate memory for each row, column in grid for each character in each line of the map text file set the corresponding gridpoint in 'gridpoints' to have its gridChar equal to that character add 'gridpoints' to the grid structure return the grid structure else return null grid_addPlayer: if parameters are not null or out of bounds identify the gridpoint in 'gridpoints' at the row and column specified if this gridpoint is an empty room spot change the player at this gridpoint to the player who is being added set the player's row, col to the row, col of this point return true return false grid_addPlayerRandom: if parameters are not null use grid_randomRoomSpots to generate an array of random room spots of size 1 take the spot at first index in the array set the player's row, col to be the room spot's row, col free the room spot free the array holding the single room spot grid_deletePlayer: if the parameters are not null or out of bounds go to the gridpoint at grid[player's row][player's column] if that gridpoint's playerID equals the given playerID set the gridpoint's playerID to null character set the player's row, col to -1, -1 return true return false grid_randomRoomSpots: given a non null grid and specified number of room spots to return create an array of int pointers with length numRows * numCols keep track of the current index position in the pointer array for each row in the grid for each col in the grid if the isEmptyRoomSpot() returns true for the point there set current index in ptr array to store that row, col increase index for position in array create an array of pointers, whose length is the specified number of room spots iterate from 0 to the given number of room spots to find pick a random room spot from the array of all room spots from above for each preceding index in the array of random rooms if the random room spot we picked is the same spot as this index store that its a duplicate break out of this inner loop if the spot is a duplicate try again at this index in next iteration else save the unique random room spot we found in our array of pointers free each row in the array of all room spots free the array of all room spots return our array of random room spots grid_placePiles: ensure params are not null or out of bounds create an int array 'piles' with its number of slots being a randomly selected number between min and max, inclusive for each integer between [0, goldTotal) pick a random slot between [0, number of slots) increment the count of the random slot in 'piles' call grid_randomRoomSpots to produce an array of *(row, column)* coordinate pairs that's the same length as 'piles' for each point in the array of room spots set the goldCount of the corresponding room spot equal to the number at this slot 'piles' set goldRemaining equal to goldTotal given free each random room row free the random room array free the array of piles grid_movePlayer: // makes use of static local funcs, movePlayerHelper and runHelper using a switch conditional structure based on given key case h return movePlayerHelper with dir = left case H return runHelper with dir = left case l return movePlayerHelper with dir = right case L return runHelper with dir = right case j return movePlayerHelper with dir = down case J return runHelper with dir = down case k return movePlayerHelper with dir = up case K return runHelper with dir = up case y return movePlayerHelper with dir = up, left case Y return runHelper with dir = up, left case u return movePlayerHelper with dir = up, right case U return runHelper with dir = up, right case b return movePlayerHelper with dir = down, left case B return runHelper with dir = down, left case n return movePlayerHelper with dir = down, right case N return runHelper with dr = down, right default return that we did not move movePlayerHelper calculate new row, col if they are out of bounds return that we did not move if the spot we are moving to is not a room spot or a passage spot return that we did not move if another player is on that spot swap places with that player update their row, col store that we collided update player's row, col with new values if grid_collectGold returns true at this spot return that we found gold if we collided return that we collided return that we moved runHelper init last attempt to move's result as didNotMove while we are able to move, try to move keep track of last attempt to move's result if we found gold or hit a player break return the last attempt's result grid_collectGold: if the parameters are not null identify the gridpoint that the player is located on if that gridpoint has goldCount greater than 0 increment the player's purse by the gridpoint's goldCount decrement the grid's goldRemaining by the gridpoint's goldCount set the gridpoint's goldCount to 0 return true else return false grid_isVisible: ensure params are not null and within bounds store change in row, col from player to given row, col if the change in row or col is zero call visibleHelperStraight calculate change in row over change in column between points calc change in col over change in row between points // case 1 if the point is below, to the right of the player current row = player row + change in row / change in col iterate through each column from player -\u0026gt; target col or out of bounds call intersectionHelper at the current row, current col if we can't see through the intersection return false increment current row by change in row / change in col current col = player's col + change in col / change in row iterate through each row from player -\u0026gt; target row or OOB call intersectionHelper at current row, col if we can't see thru intersect return false increment current col by change in col / change in row return true // nothing obstructed us, we can see it // case 2 if point is below, to the left perform same operation as case 1, but decrement col from player to target, and since change in row / change in col will be \u0026lt; 0, subtract it from currentRow instead of add (return false if at any point we determine view is obstructed) otherwise true // case 3 if point is above, to the left perform same operation as case 2, except decrement row from player to target, substracting change in col / change in row from currentCol (return false if at any point we determine view is obstructed) otherwise true // case 4 if point is above, to the right perform same operation as case 1, except decrement row from palyer to target, substracting change in col / change in row from currentCol (return false if at any point we determine view is obstructed) otherwise true return false visibleHelperStraight if change in row is zero if player col \u0026lt; target col loop from player to target if at any point view is obstructed, return false else loop from target to player if at any pt view's obstructed, return false return true if change in col is zero if player row \u0026lt; target row loop from player to target if at any pt view is obstructed, return false else loop from target to palyer if at any pt view is obstructed, return false return true return true intersectionHelper if we are checking the intersection between/on rows if the current row's an integer if we can't see through the pt at current row, col return false else if we cannot see through both the pt at floor(row), col and floor(row) + 1, col return false else if the current col's an int if we can't see through pt at current row, col return false else if we cannot see through both row, floor(col) and row, floor(col) + 1 return false return true grid_updatePlayerMap: for each row in 'gridpoints' for each gridpoint in the row if isVisible of the gridpoint is true if that gridpoint has another player on it set the corresponding char in the first player's map to the other player's playerID else if that gridpoint's gold count \u0026gt; 0 set the player's map's corresponding char to gold symbol else set the corresponding char in the player's map to the gridChar of that gridpoint else if the player's map char is gold or another player set the player's map char to whatever the corresponding gridpoint char is grid_updateSpectatorMap: if the grid and spectator passed in are valid for each row in the grid's gridpoint array for each gridpoint in that row if that gridpoint has a player on it set the corresponding gridpoint in the spectator's map to this player's player ID else if the gridpoint's gold count \u0026gt; 0 set the spectator's char there to gold symbol else set the spec's char there to this gridpoint's gridChar grid_delete: for each row in 'gridpoints' for each gridpoint in that row delete the gridpoint delete the array of gridpoints delete the grid Player Data structures The player module makes use of a player structure, which stores a 2d array of characters representing the portion of the map visible to the player, an int \u0026lsquo;purse\u0026rsquo; storing the amount of gold the player has collected, a two-slot int array \u0026lsquo;point\u0026rsquo; representing the row and column of the player, a char* representing the player\u0026rsquo;s name, a char playerID representing the player\u0026rsquo;s ID, and an addr_t representing the player\u0026rsquo;s address. If the player is a spectator, the purse and point will be set to NULL.\ntypedef struct player { char** visibleMap; char* name; char playerID; int purse; int row; int col; addr_t playerAddress; } player_t; Definition of function prototypes A function player_new to allocate a new player struct.\nplayer_t* player_new(char* name, addr_t address, char playerID, int nRows, int nColumns, int startRow, int startColumn); A function player_setMap to set the player\u0026rsquo;s visibleMap\nvoid player_setMap(player_t* player, char** map); Function to set player\u0026rsquo;s row\nvoid player_setRow(player_t* player, int row); Func to set player\u0026rsquo;s column\nvoid player_setCol(player_t* player, int col); A function player_addToPurse to add some gold to a player\u0026rsquo;s purse\nvoid player_setPurse(player_t* player, int goldAmount); A function player_getName to get the player\u0026rsquo;s name.\nchar* player_getName(player_t* player); A function player_getMap to get the player\u0026rsquo;s visibleMap\nchar** player_getMap(player_t* player); A function player_getID to get the player\u0026rsquo;s playerID\nchar** player_getID(player_t* player); A function player_getPoint to get the player\u0026rsquo;s point:\nint* player_getPoint(player_t* player); A function player_getPurse to get the player\u0026rsquo;s purse:\nint player_getPurse(player_t* player); A function player_getAddr to get the player\u0026rsquo;s address\naddr_t player_getAddr(player_t* player); A function player_mapToString to prepare the map to be sent by the server to a client.\nchar* player_mapToString(player_t* player, int numberOfRows, int numberOfColumns); A function player_delete to delete an allocated player struct\nvoid player_delete(player_t* player); Detailed pseudo code player_new\nallocate a new player struct give the player struct the given name, address, starting row \u0026amp; column allocate player's map based on given row and column sizes initialize all other values to default player_setMap\nif the given map and player are not NULL set that player's visibleMap to the given map player_addToPurse\nif the given player is not NULL increase that player's purse by specified amount player_getMap\nif the given player is not NULL return that player's map player_getPoint\nif the given player is not NULL return that player's point player_getID\nif the given player is not NULL return that player's playerID player_getPurse\nif the given player is not NULL return that player's purse player_getAddr\nif the player is not NULL return their address player_mapToString\nallocate a `char*` whose size = (number of rows * (number of cols + 1)) + 1 string_index = 0 for each row for each column if the point on the player's map is the player's ID set the char here in the string to be @ else set the char here in the string to be the char at this point on the map increment string_index set current string_index to new line char increment string_index set last index in string to be null char return result char player_delete\ndeallocate player's map deallocate player struct ","permalink":"https://srbarton43.github.io/projects/nuggets/","summary":"A multi-player exploration game inspired by Rogue","title":"Nuggets"},{"content":"About Since I string tennis racquets quite often as a part time job, I must check online various racquet-specific information such as the string pattern, holes to skip, and string length required. This information is usually hard to find, and the one website I know of, provides the data in an illegible table. Therefore I created this project to allow myself (and other users) to easily access racquet-specific string pattern information.\nSource Code Link to Repository Design Use of the GUI: The user can select the racquet brand from the top drop-down menu. Then a list of clickable racquet models appears, or a user can search for a specific model which can also be clicked in the list to display its string pattern specifications. It is quite intuitive to use (although old looking). Since PyQt is cross-platform, this app runs on Mac OS, Windows, and Linux distributions.\nView of a specific racquet model\nImplementation This entire project is written in python, the programming language I am currently using the most during my Spring 2023 Software Internship. The two main libraries which this project uses are BeautifulSoup4 for web scraping, and PyQt6 for the cross-platform graphical user interface. When the app starts up, it immediately starts scraping the home directory of www.klipperusa.com/pages/racquet-stringing-patterns to access its linked webpages for each racquet brand. For each brand the program creates a hash table of [Model-\u0026gt;Specifications] key-\u0026gt;value pairs so that this information will not have to be dynamically generated as the user interacts with the app.\n","permalink":"https://srbarton43.github.io/projects/stringerpro/","summary":"A companion app for racquet stringers","title":"StringerPro"},{"content":" Previous Next \u0026nbsp; \u0026nbsp; / [pdf] View the PDF file here. ","permalink":"https://srbarton43.github.io/writing/hiking/","summary":"Geography Final Project","title":"Staying Grounded in the Outdoors: An Investigation of Geospatial Technologies While Hiking"},{"content":" Previous Next \u0026nbsp; \u0026nbsp; / [pdf] View the PDF file here. ","permalink":"https://srbarton43.github.io/writing/labels/","summary":"A brief survey of the cyber(in)security of smart home systems and other IOT devices","title":"Not So Smart: Cybersecurity of Smart Home Systems"},{"content":" Previous Next \u0026nbsp; \u0026nbsp; / [pdf] View the PDF file here. ","permalink":"https://srbarton43.github.io/writing/allergies/","summary":"Writing 5 final project in Food for Thought","title":"Deliberately Deceptive Food Labeling: An Ongoing Conflict Between Consumer and Industry with Obesity in the Balance"},{"content":" Previous Next \u0026nbsp; \u0026nbsp; / [pdf] View the PDF file here. ","permalink":"https://srbarton43.github.io/writing/smarthomes/","summary":"Personal essay about my personal vendetta against some foods","title":"Living with ‘Allergies'"}]
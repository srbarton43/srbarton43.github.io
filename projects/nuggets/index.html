<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Nuggets | Samuel Barton</title>
<meta name=keywords content><meta name=description content="Nuggets is a multi-player exploration game inspired by Rogue. The object of the game is to collect more gold nuggets than any other player. The game ends when all gold nuggets have been collected by some player. I created this game with 3 other students as our final project for COSC50."><meta name=author content="Samuel Barton"><link rel=canonical href=https://srbarton43.github.io/projects/nuggets/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://srbarton43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://srbarton43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://srbarton43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://srbarton43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://srbarton43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://srbarton43.github.io/projects/nuggets/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Nuggets"><meta property="og:description" content="Nuggets is a multi-player exploration game inspired by Rogue. The object of the game is to collect more gold nuggets than any other player. The game ends when all gold nuggets have been collected by some player. I created this game with 3 other students as our final project for COSC50."><meta property="og:type" content="article"><meta property="og:url" content="https://srbarton43.github.io/projects/nuggets/"><meta property="og:image" content="https://srbarton43.github.io/projects/nuggets/cover.png"><meta property="article:section" content="projects"><meta property="article:published_time" content="2023-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-22T00:00:00+00:00"><meta property="og:site_name" content="Samuel Barton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://srbarton43.github.io/projects/nuggets/cover.png"><meta name=twitter:title content="Nuggets"><meta name=twitter:description content="Nuggets is a multi-player exploration game inspired by Rogue. The object of the game is to collect more gold nuggets than any other player. The game ends when all gold nuggets have been collected by some player. I created this game with 3 other students as our final project for COSC50."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://srbarton43.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Nuggets","item":"https://srbarton43.github.io/projects/nuggets/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Nuggets","name":"Nuggets","description":"Nuggets is a multi-player exploration game inspired by Rogue. The object of the game is to collect more gold nuggets than any other player. The game ends when all gold nuggets have been collected by some player. I created this game with 3 other students as our final project for COSC50.","keywords":[],"articleBody":"Design The Nuggets game requires two standalone programs, the client and the server. We have further broken down these programs into smaller modules.\nClient The client acts in one of two modes:\nspectator, the passive spectator mode player, the interactive game-playing mode Functional decomposition into modules Simply a client module, handling all client functionality.\nMajor data structures client The client data structure holds all important values for the client as a global variable:\nnrows - stores number of rows in screen ncols - stores number of cols in screen justCollected - stores number of gold just picked up for status line purse - player purse for status line goldRemaining - number of nuggets remaining map - the string representation of the map playername - the name of player, null if spectator playerID - player’s id for status line hostname - hostname of server port - port of server Server Functional decomposition into modules The grid module keeps a 2-dimensional array of gridpoints, where each gridpoint stores information about what character it is (\".\", “#”, etc.), what player is on it (if applicable) and how much gold it contains. The game module keeps track of the game grid, along with an array of the players (and any spectators) that are in the game. As outlined above, each player stores its (row, column) position, purse size, playerID, and the portion of the game grid that is currently visible to him/her. Major data structures game The game module will exist within the server to hold a state of Nuggets as it is being played, complete with the current game grid, the players, spectator, and more.\nGrid - stores data about points across map of the game array of players - stores each of the players that are in the game lastPlayerNum - Array index of player last added spectator - stores unique spectator player data, if one exists player The player module will handle various aspects of players within the game. Its uses will include storing the regions of the grid visible to the player and formatting it for clients, tracking a player’s position and how much gold they have collected, storing their name for the leaderboard, and more.\nname - stores the player’s name playerID - the player’s unique character playerID 2d character array map - represents the portion of the grid visible to the player purse - stores amount of gold the player has row - stores the player’s row col - stores the player’s column address - player’s address in the network, so we can identify players as we receive client messages grid The grid will represent the data stored on the map and at each point on the map. The grid module loads a mapfile into the game’s memory, scatters gold across open rooms, and facilitates players’ interaction with the map on the server’s end as they search for nuggets.\n2d array of gridpoints which store data about each point on the grid number of rows in the grid number of columns in the grid number of roomSpots in the grid number of gold pieces remaining in the grid Implementation The game was implemented in C, and uses the ncurses library in order to provide the text display (see https://github.com/srb-private-org/nuggets-game) .\nDiagram of Client/Server Implementation\nClient Data structures client: A global struct to track the size of client’s window, their status line in the game (which will either print the amount of gold they have or any error messages that come up), and the map that’s visible to them.\nstatic struct client { int nrows; int ncols; int justCollected; int purse; int goldRemaining; char* map; char* playername; char playerID; bool connected; char* hostname; char* port; } Definition of function prototypes A function to parse the command-line args, initialize the network:\nstatic void parseArgs(const int argc, char* argv[], char** hostname, char** port, char** playername); This function initializes the ncurses objects needed by the client, including the display.\nstatic void ncurses_init(); This function updates the display to correspond with the current state of the client.\nstatic void updateDisplay(const char* statusLine); This function is used in conjunction with message_loop to handle input.\nstatic bool handleInput(void* arg); This function sends the key input to the server.\nstatic bool sendKey(const addr_t to, int key); This function sends the player (or spectator) message to the server.\nstatic bool sendPlayMessage(const addr_t to, char* playerName); This function handles the message from server.\nstatic bool handleMessage(void* arg, const addr_t from, const char* message); This function handles the OK message.\nstatic bool handleOK(const char* message); This function handles the GRID message.\nstatic bool handleGrid(char* message); This function handles the GOLD message.\nstatic bool handleGold(char* message); This function handles the DISP message.\nstatic bool handleDisp(char* message); This function handles the QUIT message.\nstatic bool handleQuit(char* message); This function handles the ERROR message.\nstatic bool handleError(char* message); This function handles unrecognized messages.\nstatic bool handleUnrec(char* message); This function returns player status line.\nstatic char* getPlayerStatus(); This function returns spectator status line.\nstatic char* getSpectatorStatus(); Detailed pseudo code main: parse \u0026 validate command line args with parseArgs initialize log module form server address from args set ncurses (including the display) up with ncurses_init // do not init ncurses yet ; do so once we know we have received grid data from server, so we know we have a connection call sendPlayMessage with the playerName (which is null if the client is spectating) begin message_loop, passing display and functions for handling input and messages exit curses shut down communication with server parseArgs: if command line does not have two or three arguments exit nonzero if we cannot set an address to the given hostname and portnumber using message_setAddr exit nonzero ncurses_init: initialize the screen call cbreak call noecho create a new global struct client store the number of rows and columns on the screen in client's nrows and ncols set the color pair to yellow and black updateDisplay: print the status line at the top of screen print the map under the statusline call refresh to update the screen handleInput: set an adrr_t* to the void pointer passed in if that addr_t* is NULL print a message to stderr return true if that address is not a valid address print a message to stderr return true if the `connected` bool in client var hasn't been set to true log the error return true to exit set int c equal to the next keyboard press return sendKey of c sendKey: if the server passed in is NULL print an error message to log return true send message to server with form \"KEY k\" return false sendPlayMessage: if server is null print error message to stderr else if playerName is null send \"SPECTATE\" message to server else send message to server of form \"PLAY (playerName) handleMessage: if server is null print error message to stderr return true if first word is OK call handleOK with messages else if first word is GRID return handleGrid with message else if first word is GOLD return handleGold with message else if first word is DISPLAY return handleDisp with message else if first word is QUIT return handleQuit with message else if first word is ERROR return handleError with message else return handleUnrec with mesaage handleOK: parse the player ID from the message and add it to the struct return false handleGrid: call ncurses_init() since we know we are now connected set the global client var's connected field to true parse nrows and ncols from the message while client struct's nrows and ncols are less than nrows + 1 and ncols, respectively print a window sizing message to log tell the user to enlarge the window and try again return false handleGold: parse number nuggets collected parse number nuggets in purse parse number nuggets still to be found update the client struct's statusLine with these values call updateDisplay on the client struct return false handleDisp: starting after the first newline character, parse grid display string from message set client struct's map equal to that string update the map with ncurses return false handleQuit: end curses parse the message text following the word \"QUIT\" into a string print this string to stdout followed by newline return true handleError: parse explanation into string write error message to log set client's status line equal to the text in the error message call updateDisplay return false handleUnrec: log error message with log.h since unhandled message return false getPlayerStatus: return formatted status line for player in memory getSpectatorStatus: return formatted status line for spectator in memory Server Data structures Game Data Structure This data structure will store info about the current game being played, including the game grid, an array containing slots for MaxPlayers (26) players in the game. Within the server module, game data will be stored globally so that it need not be passed to and validated by every function.\nstruct gameData { grid_t* grid; player_t* players[MaxPlayers]; player_t* spectator; int nextPlayerIndex; } Definition of function prototypes A function to parse \u0026 validate the command-line arguments and initialize the game struct\nstatic int parseArgs(const int argc, char* argv[]); A function to initialize the game data struct and the grid \u0026 player data therein.\nstatic void initializeGame(char* mapFile); A function to delete the game data and the grid and player data therein.\nstatic void gameData_delete(); A function to send the game’s grid dimensions to clients\nstatic void sendGridDimensions(const addr_t to); A function to send gold information to clients.\nstatic void sendGoldInfo(const addr_t to, int justCollected, int purse, int remaining); A function to send the current display to clients.\nstatic void sendDisplay(const addr_t to, char* stringifiedMap); A function to send QUIT messages with explanations to clients.\nstatic void sendQuit(const addr_t to, const char* explanation); A function for handling messages from the client\nstatic bool handleMessage(void* arg, const addr_t from, const char* message); A function to handle SPECTATE messages.\nstatic void handleSpectateMessage(const addr_t from); A function to handle PLAY messages.\nstatic void handlePlayMessage(const addr_t from, const char* message); A function to handle KEY keystroke messages.\nstatic bool handleKeyMessage(const addr_t from, const char* message); A function to handle movement key presses\nstatic bool handleMovementCase(const int rowChange, const int columnChange, player_t* player); A function to handle unrecognized messages.\nstatic void handleUnrecognizedMessage(addr_t to, const char* message); A function to get a player pointer from its address.\nstatic player_t* getPlayerFromAddress(addr_t address); A function to send error messages to clients\nstatic void sendError(addr_t to, const char* message); A function to send OK messages to clients\nstatic void sendOK(const addr_t to); A function to check if a line is blank\nstatic bool isBlankLine(const char* string); A function to format a player name.\nstatic void formatName(char* name); A function to convert a player’s index in the players array into an ID\nstatic inline char indexToPlayerID(const int index); A function to send a game over quit message to each player.\nstatic void gameOver(); A function to update each player’s map and send it to them\nstatic void sendUpdatedMaps(); Detailed pseudo code main start logging to stderr call parseArgs() with the given cmd line args start messages module, validate init call message_loop() with handleMessage, store result in bool call gameOver() call message_done() call log_done() call gameData_delete() return zero if message loop worked, otherwise nonzero parseArgs: validate commandline args if wrong number of args is given exit with proper usage message if seed provided verify it is a valid seed number seed the random-number generator with that seed else seed the random-number generator with getpid() verify map file can be opened for reading call initializeGame() with the validated map file name initializeGame allocate memory for global gameData variable call grid_loadMap with given mapFile call grid_placePiles on the map to scatter gold across the grid allocate space for MaxPlayers in game data set spectator pointer to null in game data set nextPlayerIndex to zero in game data handleMessage given a message and sender if the message matches \"SPECTATE\" call handleSpectateMessage() with sender address elif the message begins with \"PLAY \" call handlePlayMessage() with sender address and message elif the message begins with \"KEY \" call handleKeyMessage() with sender address and message return true to exit loop if key press resulted in game ending else call handleUnrecognizedMessage, with message return false sendGridDimensions get number of rows, cols stored in game data grid build string of form \"GRID numberRows numberColumns\" send the string to the given `to` address sendGoldInfo given positive ints justCollected, purse, remaining build string of form \"GOLD justCollected purse remaining\" send string to given `to` address sendDisplay given a player call player_mapToString with the player and game grid dimensions form the message \"DISPLAY\\n\" followed by the map string send the message to the player's address free the map string allocated in memory sendQuit send \"QUIT \" followed by given explanation to `to` address handleSpectateMessage if game's spectator is not NULL sendQuit with relevant explanation to old spectator's addr call player_delete on old spectator set spectator pointer in game data to NULL call player_new with null name, given `from` address, grid dimensions, (-1,-1) as row,col, true for isSpectator if we created the player without any issues store it in gameData spectator pointer call grid_updateSpectatorMap on the spectator with the game grid call sendGridDimensions to spectator's addr with game grid dimensions call sendGoldInfo to spectator address with justCollected = 0, purse = 0, and remaining gold in grid call sendDisplay with pointer to spectator handlePlayMessage if the game's nextPlayerIndex equals MaxPlayers call sendQuit to the new player, explaining that the game's full return store the given username in memory if isBlankLine() returns true for the username sendQuit to player with explanation free the username return call formatName on the username create a new player with player_new if we failed create the player free the username, log error, and return store the player at the nextPlayerIndex in gameData increment game data's nextPlayerIndex call grid_addPlayerRandom to place the player at random room spot in grid call grid_updatePlayerMap sendGridDimensions() to player sendGoldInfo() to palyer with justCollected = 0, purse = 0, and remaining gold sendDisplay() to player update spectator's and each player's map, send it to them handleKeyMessage parse next letter if we have more than a letter or no letter sendQuit, with explanation return false (don't exit message loop) call getPlayerFromAddress() with address to matching player pointer if we failed to find a match log the error return false take the key from the message switch with key char as conditional case Q call sendQuit, w/ explanation if the player pointer points to the same place as spectator sendQuit with \"Thanks for watching!\" call player_delete on spectator set spectator pointer to NULL else call grid_deletePlayer() sendQuit with \"Thanks for playing!\" // do NOT delete quit players - only spectator // we need to keep player data for the leaderboard! update player's maps with player gone send new map to each player update spectator map send new map to spectator return false (don't exit msg loop) cases (h, l, j, k, y, u, b, n) or any of their capitalized forms return handleMovementCase with the address, player, and key default case (invalid) call handleUnrecognizedMessage sendError with \"unknown keystroke\" return false handleMovementCase given from address, player, key pressed save the player's current purse value store the result of the player's attempt to move from grid_movePlayer if the player successfully moved if the player found gold get the remaining gold in the grid if there's no remaining gold return true (to exit message loop \u0026 trigger game over) else calculate gold just collected by subtracting old purse from new purse sendGoldInfo to player with just collected gold, new purse, remaining gold loop through player array if the player is not null sendGoldInfo to the player, with 0 just collected, their purse, gold remaining if we have a spectator sendGoldInfo, with 0 just collected, 0 purse, gold remaining loop through each player if the player's not null call grid_updatePlayerMap on the player with game's grid call sendDisplay to that player if we have a spectator call grid_updateSpectatorMap call sendDisplay to the specator return false handleUnrecognizedMessage log that we could not recognize message sendError send message of form \"ERROR explanation\" to client sendOK send message of form \"OK k\" to client, where k is a given char gameOver create special game over string to send, calculating buffer large enough to hold it loop through player array in game data if the player's not null add a single line to the game over string with their ID, purse, and name loop through player array in game data if the player is not null sendQuit to their address with the game over string if we have a spectator sendQuit to their address with game over string indexToPlayerID if the index is NOT within the range of 0..MaxPlayers return null character return 'A' + index given isBlankLine for each char in given string if isspace(char) does not return true return false return true formatName if the length of the name exceeds MaxNameLength set the character in the name string at MaxNameLength to be the terminating null char loop through index in name, until we hit its length if neither isgraph(char) and isblank(char) set that char in the string to be an underscore gameData_delete if the grid in the game data is null log error, exit program for each index in player array from [0..MaxPlayers) if the player's not null call player_delete on each player free player array's memory call player_delete on the spectator, if we have one call grid_delete on the grid stored in game data free global gameData's allocated memory getPlayerFromAddress if we cannot validate the address with message_isAddr return null player pointer if player array in game data is not null loop through each player if the player isn't null if message_eqAddr(given address, player address) return pointer to that player if we have a spectator if message_eqAddr(given address, spectator address) return pointer to the spectator return null sendUpdatedMaps for each player from 0 to MaxPlayers in gameData if the player is not null update player's map send it to them if the spectator in gameData isn't null update spectator's map send it to them Grid module The grid module allows us to construct and track a grid of gridpoints, where each gridpoint stores the amount of gold it has, what player is on it (if applicable), and what character the it should display. grid also provides several methods that interact with the player module, allowing the grid of gridpoints to be continually manipulated as players move around and collect gold.\nData structures gridpoint Stores the status of a given gridpoint in the grid. Will constantly be updated as players move onto gridpoints, off of gridpoints, and collect gold.\nstruct gridpoint{ int goldCount; char gridChar; player_t* player; } grid Stores a grid of gridpoints and the amount of gold remaining in these gridpoints, along with the grid’s number of rows and columns. This struct is a crucial part of Server’s game struct, as it stores the state of a given nuggets game.\nstruct grid{ gridpoint_t** gridpoints; int goldRemaining; int numRows; int numCols; int numRooms; } Definition of function prototypes A function to load a text file into a struct grid.\ngrid_t* grid_loadMap(char* fileName); A function to insert a player at a given position in a grid. Returns true if player was inserted, false otherwise.\nbool grid_addPlayer(grid_t* grid, player_t* player, int row, int col); A function to insert a player at a random room spot in the grid.\nvoid grid_addPlayerRandom(grid_t* grid, player_t* player); A function to delete a given player from a grid. Returns true if the player could be deleted, false otherwise.\nbool grid_deletePlayer(grid_t* grid, player_t* player); A function to generate an array of ’num’ pointers to 2-slot arrays representing random (row, column) room spot coordinates in the grid.\nint** grid_randomRoomSpots(grid_t* grid, int num); A function to place n piles of gold (where n is a randomly selected integer between min and max), containing a total of goldTotal gold pieces, at random room spots in a grid.\nvoid grid_placePiles(grid_t* grid, int min, int max, int goldTotal); A function to move a player by one unit in a given direction, then modify the player’s purse accordingly. Returns a status code based on the result of the move attempt. 0 = did not move, 1 = moved, 2 = moved and found gold, 3 = moved and hit other player\nint grid_movePlayer(grid_t* grid, player_t* player, char dxn); We use the following static local function to help implement grid_movePlayer.\nstatic int movePlayerHelper(grid_t* grid, player_t* player, int row change, int colChange); We use the following static local function to help implement the run feature within grid_movePlayer\nstatic int runHelper(grid_t* grid, player_t* player, int row change, int colChange); A function to add any gold at a player’s position to their purse. Returns true if gold is collected, and false if not.\nbool grid_collectGold(grid_t* grid, player_t* player); A function to tell us whether a given gridpoint is visible to a player.\nbool grid_isVisible(grid_t* grid, player_t* player, int row, int col); A static function to help us determine whether a gridpoint is visible if the line between it and a player is straight.\nstatic bool visibleHelperStraight(grid_t* grid, int playerRow, int playerCol, int row, int col); A static function to help us determine whether a player can see through an intersection.\nstatic bool intersectionHelper(grid_t* grid, double currentRow, double currentCol, bool isRowCheck) A function to modify a player’s map to reflect what they can currently see of the grid.\nvoid grid_updatePlayerMap(grid_t* grid, player_t* player); A function to update the spectator’s map to reflect the state of the game.\nvoid grid_updateSpectatorMap(grid_t* grid, player_t* spectator); A function to delete a grid.\nvoid grid_delete(grid_t* grid); Detailed pseudo code grid_loadMap: if the text file can be opened for reading create a new grid structure count the number of rows and columns in the text file passed into the function, add them to the grid structure as numRows and numCols create an empty array gridpoints of dimensions numRows * numCols allocate memory for each row, column in grid for each character in each line of the map text file set the corresponding gridpoint in 'gridpoints' to have its gridChar equal to that character add 'gridpoints' to the grid structure return the grid structure else return null grid_addPlayer: if parameters are not null or out of bounds identify the gridpoint in 'gridpoints' at the row and column specified if this gridpoint is an empty room spot change the player at this gridpoint to the player who is being added set the player's row, col to the row, col of this point return true return false grid_addPlayerRandom: if parameters are not null use grid_randomRoomSpots to generate an array of random room spots of size 1 take the spot at first index in the array set the player's row, col to be the room spot's row, col free the room spot free the array holding the single room spot grid_deletePlayer: if the parameters are not null or out of bounds go to the gridpoint at grid[player's row][player's column] if that gridpoint's playerID equals the given playerID set the gridpoint's playerID to null character set the player's row, col to -1, -1 return true return false grid_randomRoomSpots: given a non null grid and specified number of room spots to return create an array of int pointers with length numRows * numCols keep track of the current index position in the pointer array for each row in the grid for each col in the grid if the isEmptyRoomSpot() returns true for the point there set current index in ptr array to store that row, col increase index for position in array create an array of pointers, whose length is the specified number of room spots iterate from 0 to the given number of room spots to find pick a random room spot from the array of all room spots from above for each preceding index in the array of random rooms if the random room spot we picked is the same spot as this index store that its a duplicate break out of this inner loop if the spot is a duplicate try again at this index in next iteration else save the unique random room spot we found in our array of pointers free each row in the array of all room spots free the array of all room spots return our array of random room spots grid_placePiles: ensure params are not null or out of bounds create an int array 'piles' with its number of slots being a randomly selected number between min and max, inclusive for each integer between [0, goldTotal) pick a random slot between [0, number of slots) increment the count of the random slot in 'piles' call grid_randomRoomSpots to produce an array of *(row, column)* coordinate pairs that's the same length as 'piles' for each point in the array of room spots set the goldCount of the corresponding room spot equal to the number at this slot 'piles' set goldRemaining equal to goldTotal given free each random room row free the random room array free the array of piles grid_movePlayer: // makes use of static local funcs, movePlayerHelper and runHelper using a switch conditional structure based on given key case h return movePlayerHelper with dir = left case H return runHelper with dir = left case l return movePlayerHelper with dir = right case L return runHelper with dir = right case j return movePlayerHelper with dir = down case J return runHelper with dir = down case k return movePlayerHelper with dir = up case K return runHelper with dir = up case y return movePlayerHelper with dir = up, left case Y return runHelper with dir = up, left case u return movePlayerHelper with dir = up, right case U return runHelper with dir = up, right case b return movePlayerHelper with dir = down, left case B return runHelper with dir = down, left case n return movePlayerHelper with dir = down, right case N return runHelper with dr = down, right default return that we did not move movePlayerHelper calculate new row, col if they are out of bounds return that we did not move if the spot we are moving to is not a room spot or a passage spot return that we did not move if another player is on that spot swap places with that player update their row, col store that we collided update player's row, col with new values if grid_collectGold returns true at this spot return that we found gold if we collided return that we collided return that we moved runHelper init last attempt to move's result as didNotMove while we are able to move, try to move keep track of last attempt to move's result if we found gold or hit a player break return the last attempt's result grid_collectGold: if the parameters are not null identify the gridpoint that the player is located on if that gridpoint has goldCount greater than 0 increment the player's purse by the gridpoint's goldCount decrement the grid's goldRemaining by the gridpoint's goldCount set the gridpoint's goldCount to 0 return true else return false grid_isVisible: ensure params are not null and within bounds store change in row, col from player to given row, col if the change in row or col is zero call visibleHelperStraight calculate change in row over change in column between points calc change in col over change in row between points // case 1 if the point is below, to the right of the player current row = player row + change in row / change in col iterate through each column from player -\u003e target col or out of bounds call intersectionHelper at the current row, current col if we can't see through the intersection return false increment current row by change in row / change in col current col = player's col + change in col / change in row iterate through each row from player -\u003e target row or OOB call intersectionHelper at current row, col if we can't see thru intersect return false increment current col by change in col / change in row return true // nothing obstructed us, we can see it // case 2 if point is below, to the left perform same operation as case 1, but decrement col from player to target, and since change in row / change in col will be \u003c 0, subtract it from currentRow instead of add (return false if at any point we determine view is obstructed) otherwise true // case 3 if point is above, to the left perform same operation as case 2, except decrement row from player to target, substracting change in col / change in row from currentCol (return false if at any point we determine view is obstructed) otherwise true // case 4 if point is above, to the right perform same operation as case 1, except decrement row from palyer to target, substracting change in col / change in row from currentCol (return false if at any point we determine view is obstructed) otherwise true return false visibleHelperStraight if change in row is zero if player col \u003c target col loop from player to target if at any point view is obstructed, return false else loop from target to player if at any pt view's obstructed, return false return true if change in col is zero if player row \u003c target row loop from player to target if at any pt view is obstructed, return false else loop from target to palyer if at any pt view is obstructed, return false return true return true intersectionHelper if we are checking the intersection between/on rows if the current row's an integer if we can't see through the pt at current row, col return false else if we cannot see through both the pt at floor(row), col and floor(row) + 1, col return false else if the current col's an int if we can't see through pt at current row, col return false else if we cannot see through both row, floor(col) and row, floor(col) + 1 return false return true grid_updatePlayerMap: for each row in 'gridpoints' for each gridpoint in the row if isVisible of the gridpoint is true if that gridpoint has another player on it set the corresponding char in the first player's map to the other player's playerID else if that gridpoint's gold count \u003e 0 set the player's map's corresponding char to gold symbol else set the corresponding char in the player's map to the gridChar of that gridpoint else if the player's map char is gold or another player set the player's map char to whatever the corresponding gridpoint char is grid_updateSpectatorMap: if the grid and spectator passed in are valid for each row in the grid's gridpoint array for each gridpoint in that row if that gridpoint has a player on it set the corresponding gridpoint in the spectator's map to this player's player ID else if the gridpoint's gold count \u003e 0 set the spectator's char there to gold symbol else set the spec's char there to this gridpoint's gridChar grid_delete: for each row in 'gridpoints' for each gridpoint in that row delete the gridpoint delete the array of gridpoints delete the grid Player Data structures The player module makes use of a player structure, which stores a 2d array of characters representing the portion of the map visible to the player, an int ‘purse’ storing the amount of gold the player has collected, a two-slot int array ‘point’ representing the row and column of the player, a char* representing the player’s name, a char playerID representing the player’s ID, and an addr_t representing the player’s address. If the player is a spectator, the purse and point will be set to NULL.\ntypedef struct player { char** visibleMap; char* name; char playerID; int purse; int row; int col; addr_t playerAddress; } player_t; Definition of function prototypes A function player_new to allocate a new player struct.\nplayer_t* player_new(char* name, addr_t address, char playerID, int nRows, int nColumns, int startRow, int startColumn); A function player_setMap to set the player’s visibleMap\nvoid player_setMap(player_t* player, char** map); Function to set player’s row\nvoid player_setRow(player_t* player, int row); Func to set player’s column\nvoid player_setCol(player_t* player, int col); A function player_addToPurse to add some gold to a player’s purse\nvoid player_setPurse(player_t* player, int goldAmount); A function player_getName to get the player’s name.\nchar* player_getName(player_t* player); A function player_getMap to get the player’s visibleMap\nchar** player_getMap(player_t* player); A function player_getID to get the player’s playerID\nchar** player_getID(player_t* player); A function player_getPoint to get the player’s point:\nint* player_getPoint(player_t* player); A function player_getPurse to get the player’s purse:\nint player_getPurse(player_t* player); A function player_getAddr to get the player’s address\naddr_t player_getAddr(player_t* player); A function player_mapToString to prepare the map to be sent by the server to a client.\nchar* player_mapToString(player_t* player, int numberOfRows, int numberOfColumns); A function player_delete to delete an allocated player struct\nvoid player_delete(player_t* player); Detailed pseudo code player_new\nallocate a new player struct give the player struct the given name, address, starting row \u0026 column allocate player's map based on given row and column sizes initialize all other values to default player_setMap\nif the given map and player are not NULL set that player's visibleMap to the given map player_addToPurse\nif the given player is not NULL increase that player's purse by specified amount player_getMap\nif the given player is not NULL return that player's map player_getPoint\nif the given player is not NULL return that player's point player_getID\nif the given player is not NULL return that player's playerID player_getPurse\nif the given player is not NULL return that player's purse player_getAddr\nif the player is not NULL return their address player_mapToString\nallocate a `char*` whose size = (number of rows * (number of cols + 1)) + 1 string_index = 0 for each row for each column if the point on the player's map is the player's ID set the char here in the string to be @ else set the char here in the string to be the char at this point on the map increment string_index set current string_index to new line char increment string_index set last index in string to be null char return result char player_delete\ndeallocate player's map deallocate player struct ","wordCount":"5723","inLanguage":"en","image":"https://srbarton43.github.io/projects/nuggets/cover.png","datePublished":"2023-04-22T00:00:00Z","dateModified":"2023-04-22T00:00:00Z","author":{"@type":"Person","name":"Samuel Barton"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://srbarton43.github.io/projects/nuggets/"},"publisher":{"@type":"Organization","name":"Samuel Barton","logo":{"@type":"ImageObject","url":"https://srbarton43.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://srbarton43.github.io/ accesskey=h title="Samuel Barton (Alt + H)">Samuel Barton</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://srbarton43.github.io/ title=About><span>About</span></a></li><li><a href=https://srbarton43.github.io/projects title=Projects><span>Projects</span></a></li><li><a href=https://srbarton43.github.io/writing title=Writing><span>Writing</span></a></li><li><a href=https://srbarton43.github.io/placeholder title=Resume/CV><span>Resume/CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Nuggets</h1><div class=post-description>Nuggets is a multi-player exploration game inspired by Rogue. The object of the game is to collect more gold nuggets than any other player. The game ends when all gold nuggets have been collected by some player. I created this game with 3 other students as our final project for COSC50.</div><div class=post-meta><span title='2023-04-22 00:00:00 +0000 UTC'>April 22, 2023</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;Samuel Barton</div></header><figure class=entry-cover><img loading=eager src=https://srbarton43.github.io/projects/nuggets/cover.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#design aria-label=Design>Design</a><ul><li><a href=#client aria-label=Client>Client</a><ul><li><a href=#functional-decomposition-into-modules aria-label="Functional decomposition into modules">Functional decomposition into modules</a></li><li><a href=#major-data-structures aria-label="Major data structures">Major data structures</a><ul><li><a href=#client-1 aria-label=client>client</a></li></ul></li></ul></li><li><a href=#server aria-label=Server>Server</a><ul><li><a href=#functional-decomposition-into-modules-1 aria-label="Functional decomposition into modules">Functional decomposition into modules</a></li><li><a href=#major-data-structures-1 aria-label="Major data structures">Major data structures</a><ul><li><a href=#game aria-label=game>game</a></li><li><a href=#player aria-label=player>player</a></li><li><a href=#grid aria-label=grid>grid</a></li></ul></li></ul></li></ul></li><li><a href=#implementation aria-label=Implementation>Implementation</a><ul><li><a href=#client-2 aria-label=Client>Client</a><ul><li><a href=#data-structures aria-label="Data structures">Data structures</a><ul><li><a href=#client-3 aria-label=client:>client:</a></li></ul></li><li><a href=#definition-of-function-prototypes aria-label="Definition of function prototypes">Definition of function prototypes</a></li><li><a href=#detailed-pseudo-code aria-label="Detailed pseudo code">Detailed pseudo code</a><ul><li><a href=#main aria-label=main:>main:</a></li><li><a href=#parseargs aria-label=parseArgs:>parseArgs:</a></li><li><a href=#ncurses_init aria-label=ncurses_init:>ncurses_init:</a></li><li><a href=#updatedisplay aria-label=updateDisplay:>updateDisplay:</a></li><li><a href=#handleinput aria-label=handleInput:>handleInput:</a></li><li><a href=#sendkey aria-label=sendKey:>sendKey:</a></li><li><a href=#sendplaymessage aria-label=sendPlayMessage:>sendPlayMessage:</a></li><li><a href=#handlemessage aria-label=handleMessage:>handleMessage:</a></li><li><a href=#handleok aria-label=handleOK:>handleOK:</a></li><li><a href=#handlegrid aria-label=handleGrid:>handleGrid:</a></li><li><a href=#handlegold aria-label=handleGold:>handleGold:</a></li><li><a href=#handledisp aria-label=handleDisp:>handleDisp:</a></li><li><a href=#handlequit aria-label=handleQuit:>handleQuit:</a></li><li><a href=#handleerror aria-label=handleError:>handleError:</a></li><li><a href=#handleunrec aria-label=handleUnrec:>handleUnrec:</a></li><li><a href=#getplayerstatus aria-label=getPlayerStatus:>getPlayerStatus:</a></li><li><a href=#getspectatorstatus aria-label=getSpectatorStatus:>getSpectatorStatus:</a></li></ul></li></ul></li><li><a href=#server-1 aria-label=Server>Server</a><ul><li><a href=#data-structures-1 aria-label="Data structures">Data structures</a><ul><li><a href=#game-data-structure aria-label="Game Data Structure">Game Data Structure</a></li></ul></li><li><a href=#definition-of-function-prototypes-1 aria-label="Definition of function prototypes">Definition of function prototypes</a></li><li><a href=#detailed-pseudo-code-1 aria-label="Detailed pseudo code">Detailed pseudo code</a><ul><li><a href=#main-1 aria-label=main>main</a></li><li><a href=#parseargs-1 aria-label=parseArgs:>parseArgs:</a></li><li><a href=#initializegame aria-label=initializeGame>initializeGame</a></li><li><a href=#handlemessage-1 aria-label=handleMessage>handleMessage</a></li><li><a href=#sendgriddimensions aria-label=sendGridDimensions>sendGridDimensions</a></li><li><a href=#sendgoldinfo aria-label=sendGoldInfo>sendGoldInfo</a></li><li><a href=#senddisplay aria-label=sendDisplay>sendDisplay</a></li><li><a href=#sendquit aria-label=sendQuit>sendQuit</a></li><li><a href=#handlespectatemessage aria-label=handleSpectateMessage>handleSpectateMessage</a></li><li><a href=#handleplaymessage aria-label=handlePlayMessage>handlePlayMessage</a></li><li><a href=#handlekeymessage aria-label=handleKeyMessage>handleKeyMessage</a></li><li><a href=#handlemovementcase aria-label=handleMovementCase>handleMovementCase</a></li><li><a href=#handleunrecognizedmessage aria-label=handleUnrecognizedMessage>handleUnrecognizedMessage</a></li><li><a href=#senderror aria-label=sendError>sendError</a></li><li><a href=#sendok aria-label=sendOK>sendOK</a></li><li><a href=#gameover aria-label=gameOver>gameOver</a></li><li><a href=#indextoplayerid aria-label=indexToPlayerID>indexToPlayerID</a></li><li><a href=#isblankline aria-label=isBlankLine>isBlankLine</a></li><li><a href=#formatname aria-label=formatName>formatName</a></li><li><a href=#gamedata_delete aria-label=gameData_delete>gameData_delete</a></li><li><a href=#getplayerfromaddress aria-label=getPlayerFromAddress>getPlayerFromAddress</a></li><li><a href=#sendupdatedmaps aria-label=sendUpdatedMaps>sendUpdatedMaps</a></li></ul></li></ul></li><li><a href=#grid-module aria-label="Grid module">Grid module</a><ul><li><a href=#data-structures-2 aria-label="Data structures">Data structures</a><ul><li><a href=#gridpoint aria-label=gridpoint>gridpoint</a></li><li><a href=#grid-1 aria-label=grid>grid</a></li></ul></li><li><a href=#definition-of-function-prototypes-2 aria-label="Definition of function prototypes">Definition of function prototypes</a></li><li><a href=#detailed-pseudo-code-2 aria-label="Detailed pseudo code">Detailed pseudo code</a><ul><li><a href=#grid_loadmap aria-label=grid_loadMap:>grid_loadMap:</a></li><li><a href=#grid_addplayer aria-label=grid_addPlayer:>grid_addPlayer:</a></li><li><a href=#grid_addplayerrandom aria-label=grid_addPlayerRandom:>grid_addPlayerRandom:</a></li><li><a href=#grid_deleteplayer aria-label=grid_deletePlayer:>grid_deletePlayer:</a></li><li><a href=#grid_randomroomspots aria-label=grid_randomRoomSpots:>grid_randomRoomSpots:</a></li><li><a href=#grid_placepiles aria-label=grid_placePiles:>grid_placePiles:</a></li><li><a href=#grid_moveplayer aria-label=grid_movePlayer:>grid_movePlayer:</a></li><li><a href=#moveplayerhelper aria-label=movePlayerHelper>movePlayerHelper</a></li><li><a href=#runhelper aria-label=runHelper>runHelper</a></li><li><a href=#grid_collectgold aria-label=grid_collectGold:>grid_collectGold:</a></li><li><a href=#grid_isvisible aria-label=grid_isVisible:>grid_isVisible:</a></li><li><a href=#visiblehelperstraight aria-label=visibleHelperStraight>visibleHelperStraight</a></li><li><a href=#intersectionhelper aria-label=intersectionHelper>intersectionHelper</a></li><li><a href=#grid_updateplayermap aria-label=grid_updatePlayerMap:>grid_updatePlayerMap:</a></li><li><a href=#grid_updatespectatormap aria-label=grid_updateSpectatorMap:>grid_updateSpectatorMap:</a></li><li><a href=#grid_delete aria-label=grid_delete:>grid_delete:</a></li></ul></li></ul></li><li><a href=#player-1 aria-label=Player>Player</a><ul><li><a href=#data-structures-3 aria-label="Data structures">Data structures</a></li><li><a href=#definition-of-function-prototypes-3 aria-label="Definition of function prototypes">Definition of function prototypes</a></li><li><a href=#detailed-pseudo-code-3 aria-label="Detailed pseudo code">Detailed pseudo code</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h2><p>The <em>Nuggets</em> game requires two standalone programs, the client and the server.
We have further broken down these programs into smaller modules.</p><h3 id=client>Client<a hidden class=anchor aria-hidden=true href=#client>#</a></h3><p>The <em>client</em> acts in one of two modes:</p><ol><li><em>spectator</em>, the passive spectator mode</li><li><em>player</em>, the interactive game-playing mode</li></ol><h4 id=functional-decomposition-into-modules>Functional decomposition into modules<a hidden class=anchor aria-hidden=true href=#functional-decomposition-into-modules>#</a></h4><p>Simply a client module, handling all client functionality.</p><h4 id=major-data-structures>Major data structures<a hidden class=anchor aria-hidden=true href=#major-data-structures>#</a></h4><h5 id=client-1><code>client</code><a hidden class=anchor aria-hidden=true href=#client-1>#</a></h5><p>The client data structure holds all important values for the client as a global variable:</p><ul><li>nrows - stores number of rows in screen</li><li>ncols - stores number of cols in screen</li><li>justCollected - stores number of gold just picked up for status line</li><li>purse - player purse for status line</li><li>goldRemaining - number of nuggets remaining</li><li>map - the string representation of the map</li><li>playername - the name of player, null if spectator</li><li>playerID - player&rsquo;s id for status line</li><li>hostname - hostname of server</li><li>port - port of server</li></ul><h3 id=server>Server<a hidden class=anchor aria-hidden=true href=#server>#</a></h3><h4 id=functional-decomposition-into-modules-1>Functional decomposition into modules<a hidden class=anchor aria-hidden=true href=#functional-decomposition-into-modules-1>#</a></h4><ul><li>The <em>grid</em> module keeps a 2-dimensional array of gridpoints, where each gridpoint stores information about what character it is (".", &ldquo;#&rdquo;, etc.), what player is on it (if applicable) and how much gold it contains.</li><li>The <em>game</em> module keeps track of the game grid, along with an array of the <em>players</em> (and any spectators) that are in the game. As outlined above, each player stores its <em>(row, column)</em> position, purse size, playerID, and the portion of the game grid that is currently visible to him/her.</li></ul><h4 id=major-data-structures-1>Major data structures<a hidden class=anchor aria-hidden=true href=#major-data-structures-1>#</a></h4><h5 id=game><code>game</code><a hidden class=anchor aria-hidden=true href=#game>#</a></h5><p>The game module will exist within the server to hold a state of Nuggets as it is being played, complete with the current game grid, the players, spectator, and more.</p><ul><li>Grid - stores data about points across map of the game</li><li>array of players - stores each of the players that are in the game</li><li>lastPlayerNum - Array index of player last added</li><li>spectator - stores unique spectator player data, if one exists</li></ul><h5 id=player><code>player</code><a hidden class=anchor aria-hidden=true href=#player>#</a></h5><p>The player module will handle various aspects of players within the game. Its uses will include storing the regions of the grid visible to the player and formatting it for clients, tracking a player&rsquo;s position and how much gold they have collected, storing their name for the leaderboard, and more.</p><ul><li>name - stores the player&rsquo;s name</li><li>playerID - the player&rsquo;s unique character playerID</li><li>2d character array map - represents the portion of the grid visible to the player</li><li>purse - stores amount of gold the player has</li><li>row - stores the player&rsquo;s row</li><li>col - stores the player&rsquo;s column</li><li>address - player&rsquo;s address in the network, so we can identify players as we receive client messages</li></ul><h5 id=grid><code>grid</code><a hidden class=anchor aria-hidden=true href=#grid>#</a></h5><p>The grid will represent the data stored on the map and at each point on the map. The grid module loads a mapfile into the game&rsquo;s memory, scatters gold across open rooms, and facilitates players&rsquo; interaction with the map on the server&rsquo;s end as they search for nuggets.</p><ul><li>2d array of gridpoints which store data about each point on the grid</li><li>number of rows in the grid</li><li>number of columns in the grid</li><li>number of roomSpots in the grid</li><li>number of gold pieces remaining in the grid</li></ul><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>The game was implemented in C, and uses the ncurses library in order to provide the text display (see <a href=https://github.com/srb-private-org/nuggets-game%29 target=_blank>https://github.com/srb-private-org/nuggets-game)</a>
.</p><figure><img loading=lazy src=/projects/nuggets/clientserver.png alt="Diagram of Client/Server Implementation"><figcaption><p>Diagram of Client/Server Implementation</p></figcaption></figure><h3 id=client-2>Client<a hidden class=anchor aria-hidden=true href=#client-2>#</a></h3><h4 id=data-structures>Data structures<a hidden class=anchor aria-hidden=true href=#data-structures>#</a></h4><h5 id=client-3><code>client</code>:<a hidden class=anchor aria-hidden=true href=#client-3>#</a></h5><p>A global struct to track the size of client&rsquo;s window, their status line in the game (which will either print the amount of gold they have or any error messages that come up), and the map that&rsquo;s visible to them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> client {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> nrows; 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ncols;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>int</span> justCollected;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>int</span> purse;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>int</span> goldRemaining;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> map;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> playername;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>char</span> playerID;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>bool</span> connected;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> hostname;
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> port;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=definition-of-function-prototypes>Definition of function prototypes<a hidden class=anchor aria-hidden=true href=#definition-of-function-prototypes>#</a></h4><p>A function to parse the command-line args, initialize the network:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>parseArgs</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[], <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> hostname, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> port,
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> playername);
</span></span></code></pre></div><p>This function initializes the ncurses objects needed by the client, including the display.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ncurses_init</span>();
</span></span></code></pre></div><p>This function updates the display to correspond with the current state of the client.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateDisplay</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> statusLine);
</span></span></code></pre></div><p>This function is used in conjunction with message_loop to handle input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleInput</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> arg);
</span></span></code></pre></div><p>This function sends the key input to the server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>sendKey</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> to, <span style=color:#66d9ef>int</span> key);
</span></span></code></pre></div><p>This function sends the player (or spectator) message to the server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>sendPlayMessage</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> to, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> playerName);
</span></span></code></pre></div><p>This function handles the message from server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleMessage</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> arg, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> from, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function handles the <code>OK</code> message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleOK</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function handles the <code>GRID</code> message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleGrid</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function handles the <code>GOLD</code> message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleGold</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function handles the <code>DISP</code> message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleDisp</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function handles the <code>QUIT</code> message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleQuit</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function handles the <code>ERROR</code> message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleError</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function handles unrecognized messages.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleUnrec</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>This function returns player status line.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>getPlayerStatus</span>();
</span></span></code></pre></div><p>This function returns spectator status line.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>getSpectatorStatus</span>();
</span></span></code></pre></div><h4 id=detailed-pseudo-code>Detailed pseudo code<a hidden class=anchor aria-hidden=true href=#detailed-pseudo-code>#</a></h4><h5 id=main><code>main</code>:<a hidden class=anchor aria-hidden=true href=#main>#</a></h5><pre><code>parse &amp; validate command line args with parseArgs
initialize log module
form server address from args
set ncurses (including the display) up with ncurses_init
// do not init ncurses yet ; do so once we know we have received grid data from server, so we know we have a connection
call sendPlayMessage with the playerName (which is null if the client is spectating)
begin message_loop, passing display and functions for handling input and messages
exit curses
shut down communication with server
</code></pre><h5 id=parseargs><code>parseArgs</code>:<a hidden class=anchor aria-hidden=true href=#parseargs>#</a></h5><pre><code>if command line does not have two or three arguments
	exit nonzero
if we cannot set an address to the given hostname and portnumber using message_setAddr
	exit nonzero
</code></pre><h5 id=ncurses_init><code>ncurses_init</code>:<a hidden class=anchor aria-hidden=true href=#ncurses_init>#</a></h5><pre><code>initialize the screen
call cbreak
call noecho
create a new global struct client
store the number of rows and columns on the screen in client's nrows and ncols
set the color pair to yellow and black
</code></pre><h5 id=updatedisplay><code>updateDisplay</code>:<a hidden class=anchor aria-hidden=true href=#updatedisplay>#</a></h5><pre><code>print the status line at the top of screen
print the map under the statusline
call refresh to update the screen
</code></pre><h5 id=handleinput><code>handleInput</code>:<a hidden class=anchor aria-hidden=true href=#handleinput>#</a></h5><pre><code>set an adrr_t* to the void pointer passed in
if that addr_t* is NULL
	print a message to stderr
	return true
if that address is not a valid address
	print a message to stderr 
	return true
if the `connected` bool in client var hasn't been set to true
	log the error
	return true to exit

set int c equal to the next keyboard press
return sendKey of c
</code></pre><h5 id=sendkey><code>sendKey</code>:<a hidden class=anchor aria-hidden=true href=#sendkey>#</a></h5><pre><code>if the server passed in is NULL
	print an error message to log
	return true
send message to server with form &quot;KEY k&quot;
return false
</code></pre><h5 id=sendplaymessage><code>sendPlayMessage</code>:<a hidden class=anchor aria-hidden=true href=#sendplaymessage>#</a></h5><pre><code>if server is null
	print error message to stderr
else if playerName is null
	send &quot;SPECTATE&quot; message to server
else
	send message to server of form &quot;PLAY (playerName)
</code></pre><h5 id=handlemessage><code>handleMessage</code>:<a hidden class=anchor aria-hidden=true href=#handlemessage>#</a></h5><pre><code>if server is null
	print error message to stderr
	return true
if first word is OK
	call handleOK with messages
else if first word is GRID
	return handleGrid with message
else if first word is GOLD
	return handleGold with message
else if first word is DISPLAY
	return handleDisp  with message
else if first word is QUIT
	return handleQuit with message
else if first word is ERROR
	return handleError with message
else
	return handleUnrec with mesaage
</code></pre><h5 id=handleok><code>handleOK</code>:<a hidden class=anchor aria-hidden=true href=#handleok>#</a></h5><pre><code>parse the player ID from the message and add it to the struct
return false
</code></pre><h5 id=handlegrid><code>handleGrid</code>:<a hidden class=anchor aria-hidden=true href=#handlegrid>#</a></h5><pre><code>call ncurses_init() since we know we are now connected
set the global client var's connected field to true
parse nrows and ncols from the message
	while client struct's nrows and ncols are less than nrows + 1 and ncols, respectively
		print a window sizing message to log
		tell the user to enlarge the window and try again
return false
</code></pre><h5 id=handlegold><code>handleGold</code>:<a hidden class=anchor aria-hidden=true href=#handlegold>#</a></h5><pre><code>parse number nuggets collected
parse number nuggets in purse 
parse number nuggets still to be found
update the client struct's statusLine with these values
call updateDisplay on the client struct
return false
</code></pre><h5 id=handledisp><code>handleDisp</code>:<a hidden class=anchor aria-hidden=true href=#handledisp>#</a></h5><pre><code>starting after the first newline character, parse grid display string from message
set client struct's map equal to that string
update the map with ncurses
return false
</code></pre><h5 id=handlequit><code>handleQuit</code>:<a hidden class=anchor aria-hidden=true href=#handlequit>#</a></h5><pre><code>end curses
parse the message text following the word &quot;QUIT&quot; into a string
print this string to stdout followed by newline
return true
</code></pre><h5 id=handleerror><code>handleError</code>:<a hidden class=anchor aria-hidden=true href=#handleerror>#</a></h5><pre><code>parse explanation into string
write error message to log
set client's status line equal to the text in the error message
call updateDisplay
return false
</code></pre><h5 id=handleunrec><code>handleUnrec</code>:<a hidden class=anchor aria-hidden=true href=#handleunrec>#</a></h5><pre><code>log error message with log.h since unhandled message
return false
</code></pre><h5 id=getplayerstatus><code>getPlayerStatus</code>:<a hidden class=anchor aria-hidden=true href=#getplayerstatus>#</a></h5><pre><code>return formatted status line for player in memory
</code></pre><h5 id=getspectatorstatus><code>getSpectatorStatus</code>:<a hidden class=anchor aria-hidden=true href=#getspectatorstatus>#</a></h5><pre><code>return formatted status line for spectator in memory
</code></pre><h3 id=server-1>Server<a hidden class=anchor aria-hidden=true href=#server-1>#</a></h3><h4 id=data-structures-1>Data structures<a hidden class=anchor aria-hidden=true href=#data-structures-1>#</a></h4><h5 id=game-data-structure>Game Data Structure<a hidden class=anchor aria-hidden=true href=#game-data-structure>#</a></h5><p>This data structure will store info about the current game being played, including the game grid, an array containing slots for <code>MaxPlayers</code> (26) players in the game. Within the server module, game data will be stored globally so that it need not be passed to and validated by every function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> gameData {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> players[MaxPlayers];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> spectator;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> nextPlayerIndex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=definition-of-function-prototypes-1>Definition of function prototypes<a hidden class=anchor aria-hidden=true href=#definition-of-function-prototypes-1>#</a></h4><p>A function to parse & validate the command-line arguments and initialize the game struct</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>parseArgs</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[]);
</span></span></code></pre></div><p>A function to initialize the game data struct and the grid & player data therein.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initializeGame</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> mapFile);
</span></span></code></pre></div><p>A function to delete the game data and the grid and player data therein.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>gameData_delete</span>();
</span></span></code></pre></div><p>A function to send the game&rsquo;s grid dimensions to clients</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendGridDimensions</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> to);
</span></span></code></pre></div><p>A function to send gold information to clients.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendGoldInfo</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> to, <span style=color:#66d9ef>int</span> justCollected, <span style=color:#66d9ef>int</span> purse, <span style=color:#66d9ef>int</span> remaining);
</span></span></code></pre></div><p>A function to send the current display to clients.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendDisplay</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> to, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> stringifiedMap);
</span></span></code></pre></div><p>A function to send QUIT messages with explanations to clients.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendQuit</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> to, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> explanation);
</span></span></code></pre></div><p>A function for handling messages from the client</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleMessage</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> arg, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> from, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>A function to handle <code>SPECTATE</code> messages.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleSpectateMessage</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> from);
</span></span></code></pre></div><p>A function to handle <code>PLAY</code> messages.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handlePlayMessage</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> from, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>A function to handle <code>KEY</code> keystroke messages.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleKeyMessage</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> from, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>A function to handle movement key presses</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>handleMovementCase</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> rowChange, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> columnChange, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function to handle unrecognized messages.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleUnrecognizedMessage</span>(<span style=color:#66d9ef>addr_t</span> to, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>A function to get a player pointer from its address.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>getPlayerFromAddress</span>(<span style=color:#66d9ef>addr_t</span> address);
</span></span></code></pre></div><p>A function to send error messages to clients</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendError</span>(<span style=color:#66d9ef>addr_t</span> to, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> message);
</span></span></code></pre></div><p>A function to send OK messages to clients</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendOK</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>addr_t</span> to);
</span></span></code></pre></div><p>A function to check if a line is blank</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isBlankLine</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> string);
</span></span></code></pre></div><p>A function to format a player name.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>formatName</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name);
</span></span></code></pre></div><p>A function to convert a player&rsquo;s index in the players array into an ID</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>char</span> <span style=color:#a6e22e>indexToPlayerID</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> index);
</span></span></code></pre></div><p>A function to send a game over quit message to each player.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>gameOver</span>();
</span></span></code></pre></div><p>A function to update each player&rsquo;s map and send it to them</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendUpdatedMaps</span>();
</span></span></code></pre></div><h4 id=detailed-pseudo-code-1>Detailed pseudo code<a hidden class=anchor aria-hidden=true href=#detailed-pseudo-code-1>#</a></h4><h5 id=main-1>main<a hidden class=anchor aria-hidden=true href=#main-1>#</a></h5><pre><code>start logging to stderr
call parseArgs() with the given cmd line args
start messages module, validate init
call message_loop() with handleMessage, store result in bool
call gameOver()
call message_done()
call log_done()
call gameData_delete()
return zero if message loop worked, otherwise nonzero
</code></pre><h5 id=parseargs-1><code>parseArgs</code>:<a hidden class=anchor aria-hidden=true href=#parseargs-1>#</a></h5><pre><code>validate commandline args
if wrong number of args is given
	exit with proper usage message
if seed provided
	verify it is a valid seed number
	seed the random-number generator with that seed
else
	seed the random-number generator with getpid()
verify map file can be opened for reading
call initializeGame() with the validated map file name
</code></pre><h5 id=initializegame><code>initializeGame</code><a hidden class=anchor aria-hidden=true href=#initializegame>#</a></h5><pre><code>allocate memory for global gameData variable
call grid_loadMap with given mapFile
call grid_placePiles on the map to scatter gold across the grid
allocate space for MaxPlayers in game data
set spectator pointer to null in game data
set nextPlayerIndex to zero in game data
</code></pre><h5 id=handlemessage-1><code>handleMessage</code><a hidden class=anchor aria-hidden=true href=#handlemessage-1>#</a></h5><pre><code>given a message and sender
if the message matches &quot;SPECTATE&quot;
	call handleSpectateMessage() with sender address
elif the message begins with &quot;PLAY &quot;
	call handlePlayMessage() with sender address and message
elif the message begins with &quot;KEY &quot;
	call handleKeyMessage() with sender address and message
	return true to exit loop if key press resulted in game ending
else
	call handleUnrecognizedMessage, with message
return false
</code></pre><h5 id=sendgriddimensions><code>sendGridDimensions</code><a hidden class=anchor aria-hidden=true href=#sendgriddimensions>#</a></h5><pre><code>get number of rows, cols stored in game data grid
build string of form &quot;GRID numberRows numberColumns&quot;
send the string to the given `to` address
</code></pre><h5 id=sendgoldinfo><code>sendGoldInfo</code><a hidden class=anchor aria-hidden=true href=#sendgoldinfo>#</a></h5><pre><code>given positive ints justCollected, purse, remaining
build string of form &quot;GOLD justCollected purse remaining&quot;
send string to given `to` address
</code></pre><h5 id=senddisplay><code>sendDisplay</code><a hidden class=anchor aria-hidden=true href=#senddisplay>#</a></h5><pre><code>given a player
call player_mapToString with the player and game grid dimensions
form the message &quot;DISPLAY\n&quot; followed by the map string
send the message to the player's address
free the map string allocated in memory
</code></pre><h5 id=sendquit><code>sendQuit</code><a hidden class=anchor aria-hidden=true href=#sendquit>#</a></h5><pre><code>send &quot;QUIT &quot; followed by given explanation to `to` address
</code></pre><h5 id=handlespectatemessage><code>handleSpectateMessage</code><a hidden class=anchor aria-hidden=true href=#handlespectatemessage>#</a></h5><pre><code>if game's spectator is not NULL
	sendQuit with relevant explanation to old spectator's addr
	call player_delete on old spectator
	set spectator pointer in game data to NULL
call player_new with null name, given `from` address, grid dimensions, (-1,-1) as row,col, true for isSpectator
if we created the player without any issues
	store it in gameData spectator pointer
call grid_updateSpectatorMap on the spectator with the game grid
call sendGridDimensions to spectator's addr with game grid dimensions
call sendGoldInfo to spectator address with justCollected = 0, purse = 0, and remaining gold in grid
call sendDisplay with pointer to spectator
</code></pre><h5 id=handleplaymessage><code>handlePlayMessage</code><a hidden class=anchor aria-hidden=true href=#handleplaymessage>#</a></h5><pre><code>if the game's nextPlayerIndex equals MaxPlayers
	call sendQuit to the new player, explaining that the game's full
	return
store the given username in memory
if isBlankLine() returns true for the username
	sendQuit to player with explanation
	free the username
	return
call formatName on the username
create a new player with player_new
if we failed create the player
	free the username, log error, and return
store the player at the nextPlayerIndex in gameData
increment game data's nextPlayerIndex
call grid_addPlayerRandom to place the player at random room spot in grid
call grid_updatePlayerMap
sendGridDimensions() to player
sendGoldInfo() to palyer with justCollected = 0, purse = 0, and remaining gold
sendDisplay() to player
update spectator's and each player's map, send it to them
</code></pre><h5 id=handlekeymessage><code>handleKeyMessage</code><a hidden class=anchor aria-hidden=true href=#handlekeymessage>#</a></h5><pre><code>parse next letter 
if we have more than a letter or no letter
	sendQuit, with explanation
	return false (don't exit message loop)
call getPlayerFromAddress() with address to matching player pointer
if we failed to find a match
	log the error
	return false
take the key from the message
switch with key char as conditional
	case Q
		call sendQuit, w/ explanation
		if the player pointer points to the same place as spectator
			sendQuit with &quot;Thanks for watching!&quot;
			call player_delete on spectator
			set spectator pointer to NULL
		else
			call grid_deletePlayer()
			sendQuit with &quot;Thanks for playing!&quot;
			// do NOT delete quit players - only spectator
			// we need to keep player data for the leaderboard!
			update player's maps with player gone
			send new map to each player
			update spectator map
			send new map to spectator
		return false (don't exit msg loop)
	cases (h, l, j, k, y, u, b, n) or any of their capitalized forms
		return handleMovementCase with the address, player, and key
	default case (invalid)
		call handleUnrecognizedMessage
		sendError with &quot;unknown keystroke&quot;
return false
</code></pre><h5 id=handlemovementcase><code>handleMovementCase</code><a hidden class=anchor aria-hidden=true href=#handlemovementcase>#</a></h5><pre><code>given from address, player, key pressed
save the player's current purse value
store the result of the player's attempt to move from grid_movePlayer
if the player successfully moved
	if the player found gold
		get the remaining gold in the grid
		if there's no remaining gold
			return true (to exit message loop &amp; trigger game over)
		else
			calculate gold just collected by subtracting old purse from new purse
			sendGoldInfo to player with just collected gold, new purse, remaining gold
			loop through player array
				if the player is not null
					sendGoldInfo to the player, with 0 just collected, their purse, gold remaining
			if we have a spectator
				sendGoldInfo, with 0 just collected, 0 purse, gold remaining
	loop through each player
		if the player's not null
			call grid_updatePlayerMap on the player with game's grid
			call sendDisplay to that player
	if we have a spectator
		call grid_updateSpectatorMap
		call sendDisplay to the specator
return false
</code></pre><h5 id=handleunrecognizedmessage><code>handleUnrecognizedMessage</code><a hidden class=anchor aria-hidden=true href=#handleunrecognizedmessage>#</a></h5><pre><code>log that we could not recognize message
</code></pre><h5 id=senderror><code>sendError</code><a hidden class=anchor aria-hidden=true href=#senderror>#</a></h5><pre><code>send message of form &quot;ERROR explanation&quot; to client
</code></pre><h5 id=sendok><code>sendOK</code><a hidden class=anchor aria-hidden=true href=#sendok>#</a></h5><pre><code>send message of form &quot;OK k&quot; to client, where k is a given char
</code></pre><h5 id=gameover><code>gameOver</code><a hidden class=anchor aria-hidden=true href=#gameover>#</a></h5><pre><code>create special game over string to send, calculating buffer large enough to hold it
loop through player array in game data
	if the player's not null
		add a single line to the game over string with their ID, purse, and name
loop through player array in game data
	if the player is not null
		sendQuit to their address with the game over string 
if we have a spectator
	sendQuit to their address with game over string
</code></pre><h5 id=indextoplayerid><code>indexToPlayerID</code><a hidden class=anchor aria-hidden=true href=#indextoplayerid>#</a></h5><pre><code>if the index is NOT within the range of 0..MaxPlayers
	return null character
return 'A' + index given
</code></pre><h5 id=isblankline><code>isBlankLine</code><a hidden class=anchor aria-hidden=true href=#isblankline>#</a></h5><pre><code>for each char in given string
	if isspace(char) does not return true
		return false
return true
</code></pre><h5 id=formatname><code>formatName</code><a hidden class=anchor aria-hidden=true href=#formatname>#</a></h5><pre><code>if the length of the name exceeds MaxNameLength
	set the character in the name string at MaxNameLength to be the terminating null char
loop through index in name, until we hit its length
	if neither isgraph(char) and isblank(char)
		set that char in the string to be an underscore
</code></pre><h5 id=gamedata_delete><code>gameData_delete</code><a hidden class=anchor aria-hidden=true href=#gamedata_delete>#</a></h5><pre><code>if the grid in the game data is null
	log error, exit program
for each index in player array from [0..MaxPlayers)
	if the player's not null
		call player_delete on each player
free player array's memory
call player_delete on the spectator, if we have one
call grid_delete on the grid stored in game data
free global gameData's allocated memory
</code></pre><h5 id=getplayerfromaddress><code>getPlayerFromAddress</code><a hidden class=anchor aria-hidden=true href=#getplayerfromaddress>#</a></h5><pre><code>if we cannot validate the address with message_isAddr
	return null player pointer
if player array in game data is not null
	loop through each player
		if the player isn't null
			if message_eqAddr(given address, player address)
				return pointer to that player
if we have a spectator
	if message_eqAddr(given address, spectator address)
		return pointer to the spectator
return null
</code></pre><h5 id=sendupdatedmaps><code>sendUpdatedMaps</code><a hidden class=anchor aria-hidden=true href=#sendupdatedmaps>#</a></h5><pre><code>for each player from 0 to MaxPlayers in gameData
	if the player is not null
		update player's map
		send it to them
if the spectator in gameData isn't null
	update spectator's map
	send it to them
</code></pre><hr><h3 id=grid-module>Grid module<a hidden class=anchor aria-hidden=true href=#grid-module>#</a></h3><p>The <code>grid</code> module allows us to construct and track a grid of <em>gridpoints</em>, where each gridpoint stores the amount of gold it has, what player is on it (if applicable), and what character the it should display. <code>grid</code> also provides several methods that interact with the <code>player</code> module, allowing the grid of gridpoints to be continually manipulated as players move around and collect gold.</p><h4 id=data-structures-2>Data structures<a hidden class=anchor aria-hidden=true href=#data-structures-2>#</a></h4><h5 id=gridpoint>gridpoint<a hidden class=anchor aria-hidden=true href=#gridpoint>#</a></h5><p>Stores the status of a given gridpoint in the grid. Will constantly be updated as players move onto gridpoints, off of gridpoints, and collect gold.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> gridpoint{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> goldCount;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> gridChar;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=grid-1>grid<a hidden class=anchor aria-hidden=true href=#grid-1>#</a></h5><p>Stores a grid of gridpoints and the amount of gold remaining in these gridpoints, along with the grid&rsquo;s number of rows and columns. This struct is a crucial part of Server&rsquo;s game struct, as it stores the state of a given nuggets game.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> grid{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>gridpoint_t</span><span style=color:#f92672>**</span> gridpoints;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> goldRemaining;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> numRows;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> numCols;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> numRooms;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=definition-of-function-prototypes-2>Definition of function prototypes<a hidden class=anchor aria-hidden=true href=#definition-of-function-prototypes-2>#</a></h4><p>A function to load a text file into a struct grid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>grid_loadMap</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> fileName);
</span></span></code></pre></div><p>A function to insert a player at a given position in a grid. Returns true if player was inserted, false otherwise.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>grid_addPlayer</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col);
</span></span></code></pre></div><p>A function to insert a player at a random room spot in the grid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grid_addPlayerRandom</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function to delete a given player from a grid. Returns true if the player could be deleted, false otherwise.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>grid_deletePlayer</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function to generate an array of &rsquo;num&rsquo; pointers to 2-slot arrays representing random <em>(row, column)</em> room spot coordinates in the grid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> <span style=color:#a6e22e>grid_randomRoomSpots</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>int</span> num);
</span></span></code></pre></div><p>A function to place n piles of gold (where n is a randomly selected integer between min and max), containing a total of goldTotal gold pieces, at random room spots in a grid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grid_placePiles</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>int</span> min, <span style=color:#66d9ef>int</span> max, <span style=color:#66d9ef>int</span> goldTotal);
</span></span></code></pre></div><p>A function to move a player by one unit in a given direction, then modify the player&rsquo;s purse accordingly. Returns a status code based
on the result of the move attempt. 0 = did not move, 1 = moved, 2 =
moved and found gold, 3 = moved and hit other player</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>grid_movePlayer</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>char</span> dxn);
</span></span></code></pre></div><p>We use the following static local function to help implement grid_movePlayer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>movePlayerHelper</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> row change, <span style=color:#66d9ef>int</span> colChange);
</span></span></code></pre></div><p>We use the following static local function to help implement the run feature within grid_movePlayer</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>runHelper</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> row change, <span style=color:#66d9ef>int</span> colChange);
</span></span></code></pre></div><p>A function to add any gold at a player&rsquo;s position to their purse. Returns true if gold is collected, and false if not.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>grid_collectGold</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function to tell us whether a given gridpoint is visible to a player.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>grid_isVisible</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col);
</span></span></code></pre></div><p>A static function to help us determine whether a gridpoint is visible if the line between it and a player is straight.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>visibleHelperStraight</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>int</span> playerRow, <span style=color:#66d9ef>int</span> playerCol, <span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col);
</span></span></code></pre></div><p>A static function to help us determine whether a player can see through an intersection.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>intersectionHelper</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>double</span> currentRow, <span style=color:#66d9ef>double</span> currentCol, <span style=color:#66d9ef>bool</span> isRowCheck)
</span></span></code></pre></div><p>A function to modify a player&rsquo;s map to reflect what they can currently see of the grid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grid_updatePlayerMap</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function to update the spectator&rsquo;s map to reflect the state of the game.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grid_updateSpectatorMap</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid, <span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> spectator);
</span></span></code></pre></div><p>A function to delete a grid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grid_delete</span>(<span style=color:#66d9ef>grid_t</span><span style=color:#f92672>*</span> grid);
</span></span></code></pre></div><h4 id=detailed-pseudo-code-2>Detailed pseudo code<a hidden class=anchor aria-hidden=true href=#detailed-pseudo-code-2>#</a></h4><h5 id=grid_loadmap><code>grid_loadMap</code>:<a hidden class=anchor aria-hidden=true href=#grid_loadmap>#</a></h5><pre><code>if the text file can be opened for reading
	create a new grid structure
	count the number of rows and columns in the text file passed into the function, add them to the grid structure as numRows and numCols
	create an empty array gridpoints of dimensions numRows * numCols
	allocate memory for each row, column in grid
	for each character in each line of the map text file
    	set the corresponding gridpoint in 'gridpoints' to have its gridChar equal to that character
	add 'gridpoints' to the grid structure
	return the grid structure
else
	return null
</code></pre><h5 id=grid_addplayer><code>grid_addPlayer</code>:<a hidden class=anchor aria-hidden=true href=#grid_addplayer>#</a></h5><pre><code>if parameters are not null or out of bounds
	identify the gridpoint in 'gridpoints' at the row and column specified
	if this gridpoint is an empty room spot
		change the player at this gridpoint to the player who is being added
		set the player's row, col to the row, col of this point
		return true
return false
</code></pre><h5 id=grid_addplayerrandom><code>grid_addPlayerRandom</code>:<a hidden class=anchor aria-hidden=true href=#grid_addplayerrandom>#</a></h5><pre><code>if parameters are not null
	use grid_randomRoomSpots to generate an array of random room spots of size 1
	take the spot at first index in the array
	set the player's row, col to be the room spot's row, col
	free the room spot 
	free the array holding the single room spot
</code></pre><h5 id=grid_deleteplayer><code>grid_deletePlayer</code>:<a hidden class=anchor aria-hidden=true href=#grid_deleteplayer>#</a></h5><pre><code>if the parameters are not null or out of bounds
	go to the gridpoint at grid[player's row][player's column]
	if that gridpoint's playerID equals the given playerID
		set the gridpoint's playerID to null character
		set the player's row, col to -1, -1
		return true
return false
</code></pre><h5 id=grid_randomroomspots><code>grid_randomRoomSpots</code>:<a hidden class=anchor aria-hidden=true href=#grid_randomroomspots>#</a></h5><pre><code>given a non null grid and specified number of room spots to return
create an array of int pointers with length numRows * numCols 
keep track of the current index position in the pointer array
for each row in the grid
	for each col in the grid
		if the isEmptyRoomSpot() returns true for the point there
		set current index in ptr array to store that row, col
		increase index for position in array
create an array of pointers, whose length is the specified number of room spots
iterate from 0 to the given number of room spots to find
	pick a random room spot from the array of all room spots from above
	for each preceding index in the array of random rooms
		if the random room spot we picked is the same spot as this index
			store that its a duplicate
			break out of this inner loop
	if the spot is a duplicate
		try again at this index in next iteration
	else
		save the unique random room spot we found in our array of pointers

free each row in the array of all room spots
free the array of all room spots

return our array of random room spots
</code></pre><h5 id=grid_placepiles><code>grid_placePiles</code>:<a hidden class=anchor aria-hidden=true href=#grid_placepiles>#</a></h5><pre><code>ensure params are not null or out of bounds
create an int array 'piles' with its number of slots being a randomly selected number between min and max, inclusive
for each integer between [0, goldTotal)
	pick a random slot between [0, number of slots)
    increment the count of the random slot in 'piles'
call grid_randomRoomSpots to produce an array of *(row, column)* coordinate pairs that's the same length as 'piles'
for each point in the array of room spots
    set the goldCount of the corresponding room spot equal to the number at this slot 'piles'
set goldRemaining equal to goldTotal given
free each random room row
free the random room array
free the array of piles
</code></pre><h5 id=grid_moveplayer><code>grid_movePlayer</code>:<a hidden class=anchor aria-hidden=true href=#grid_moveplayer>#</a></h5><pre><code>// makes use of static local funcs, movePlayerHelper and runHelper
using a switch conditional structure based on given key
	case h
		return movePlayerHelper with dir = left
	case H
		return runHelper with dir = left
	case l
		return movePlayerHelper with dir = right
	case L
		return runHelper with dir = right
	case j
		return movePlayerHelper with dir = down
	case J
		return runHelper with dir = down
	case k
		return movePlayerHelper with dir = up
	case K
		return runHelper with dir = up
	case y
		return movePlayerHelper with dir = up, left
	case Y
		return runHelper with dir = up, left
	case u
		return movePlayerHelper with dir = up, right
	case U
		return runHelper with dir = up, right
	case b
		return movePlayerHelper with dir = down, left
	case B
		return runHelper with dir = down, left
	case n
		return movePlayerHelper with dir = down, right
	case N
		return runHelper with dr = down, right
	default
		return that we did not move
</code></pre><h5 id=moveplayerhelper><code>movePlayerHelper</code><a hidden class=anchor aria-hidden=true href=#moveplayerhelper>#</a></h5><pre><code>calculate new row, col
if they are out of bounds
	return that we did not move
if the spot we are moving to is not a room spot or a passage spot
	return that we did not move
if another player is on that spot
	swap places with that player
	update their row, col
	store that we collided
update player's row, col with new values
if grid_collectGold returns true at this spot
	return that we found gold
if we collided
	return that we collided
return that we moved
</code></pre><h5 id=runhelper><code>runHelper</code><a hidden class=anchor aria-hidden=true href=#runhelper>#</a></h5><pre><code>init last attempt to move's result as didNotMove
while we are able to move, try to move
	keep track of last attempt to move's result
	if we found gold or hit a player
		break
return the last attempt's result
</code></pre><h5 id=grid_collectgold><code>grid_collectGold</code>:<a hidden class=anchor aria-hidden=true href=#grid_collectgold>#</a></h5><pre><code>if the parameters are not null
	identify the gridpoint that the player is located on
	if that gridpoint has goldCount greater than 0
		increment the player's purse by the gridpoint's goldCount
		decrement the grid's goldRemaining by the gridpoint's goldCount
		set the gridpoint's goldCount to 0
		return true
	else
		return false
</code></pre><h5 id=grid_isvisible><code>grid_isVisible</code>:<a hidden class=anchor aria-hidden=true href=#grid_isvisible>#</a></h5><pre><code>ensure params are not null and within bounds
store change in row, col from player to given row, col
if the change in row or col is zero
	call visibleHelperStraight

calculate change in row over change in column between points
calc change in col over change in row between points

// case 1
if the point is below, to the right of the player
	current row = player row + change in row / change in col
	iterate through each column from player -&gt; target col or out of bounds
		call intersectionHelper at the current row, current col
		if we can't see through the intersection
			return false
		increment current row by change in row / change in col
	current col = player's col + change in col / change in row
	iterate through each row from player -&gt; target row or OOB
		call intersectionHelper at current row, col
		if we can't see thru intersect
			return false
		increment current col by change in col / change in row
	return true // nothing obstructed us, we can see it

// case 2
if point is below, to the left
	perform same operation as case 1, but decrement col from player to target, and since change in row / change in col will be &lt; 0, subtract it from currentRow instead of add 
	(return false if at any point we determine view is obstructed) otherwise true

// case 3
if point is above, to the left
	perform same operation as case 2, except decrement row from player to target, substracting change in col / change in row from currentCol
	(return false if at any point we determine view is obstructed) otherwise true

// case 4
if point is above, to the right
	perform same operation as case 1, except decrement row from palyer to target, substracting change in col / change in row from currentCol
	(return false if at any point we determine view is obstructed) otherwise true

return false
</code></pre><h5 id=visiblehelperstraight><code>visibleHelperStraight</code><a hidden class=anchor aria-hidden=true href=#visiblehelperstraight>#</a></h5><pre><code>if change in row is zero
	if player col &lt; target col
		loop from player to target
			if at any point view is obstructed, return false
	else
		loop from target to player
			if at any pt view's obstructed, return false
	return true
if change in col is zero
	if player row &lt; target row
		loop from player to target
			if at any pt view is obstructed, return false
	else
		loop from target to palyer
			if at any pt view is obstructed, return false
	return true
return true
</code></pre><h5 id=intersectionhelper><code>intersectionHelper</code><a hidden class=anchor aria-hidden=true href=#intersectionhelper>#</a></h5><pre><code>if we are checking the intersection between/on rows
	if the current row's an integer
		if we can't see through the pt at current row, col
			return false
	else
		if we cannot see through both the pt at floor(row), col and floor(row) + 1, col
			return false
else
	if the current col's an int
		if we can't see through pt at current row, col
			return false
	else
		if we cannot see through both row, floor(col) and row, floor(col) + 1
			return false
return true
</code></pre><h5 id=grid_updateplayermap><code>grid_updatePlayerMap</code>:<a hidden class=anchor aria-hidden=true href=#grid_updateplayermap>#</a></h5><pre><code>for each row in 'gridpoints'
	for each gridpoint in the row
		if isVisible of the gridpoint is true
			if that gridpoint has another player on it
				set the corresponding char in the first player's map to the other player's playerID
			else
				if that gridpoint's gold count &gt; 0
					set the player's map's corresponding char to gold symbol
				else
					set the corresponding char in the player's map to the gridChar of that gridpoint
		else
			if the player's map char is gold or another player
				set the player's map char to whatever the corresponding gridpoint char is
</code></pre><h5 id=grid_updatespectatormap><code>grid_updateSpectatorMap</code>:<a hidden class=anchor aria-hidden=true href=#grid_updatespectatormap>#</a></h5><pre><code>if the grid and spectator passed in are valid
	for each row in the grid's gridpoint array
		for each gridpoint in that row
			if that gridpoint has a player on it
				set the corresponding gridpoint in the spectator's map to this player's player ID
			else
				if the gridpoint's gold count &gt; 0
					set the spectator's char there to gold symbol
				else
					set the spec's char there to this gridpoint's gridChar
</code></pre><h5 id=grid_delete><code>grid_delete</code>:<a hidden class=anchor aria-hidden=true href=#grid_delete>#</a></h5><pre><code>for each row in 'gridpoints'
	for each gridpoint in that row
		delete the gridpoint
delete the array of gridpoints
delete the grid
</code></pre><hr><h3 id=player-1>Player<a hidden class=anchor aria-hidden=true href=#player-1>#</a></h3><h4 id=data-structures-3>Data structures<a hidden class=anchor aria-hidden=true href=#data-structures-3>#</a></h4><p>The player module makes use of a <code>player</code> structure, which stores a 2d array of characters representing the portion of the map visible to the player, an int &lsquo;purse&rsquo; storing the amount of gold the player has collected, a two-slot int array &lsquo;point&rsquo; representing the row and column of the player, a char* representing the player&rsquo;s name, a char playerID representing the player&rsquo;s ID, and an addr_t representing the player&rsquo;s address. If the player is a spectator, the purse and point will be set to NULL.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> player {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> visibleMap; 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> playerID;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> purse;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> row;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> col;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>addr_t</span> playerAddress;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>player_t</span>;
</span></span></code></pre></div><h4 id=definition-of-function-prototypes-3>Definition of function prototypes<a hidden class=anchor aria-hidden=true href=#definition-of-function-prototypes-3>#</a></h4><p>A function <code>player_new</code> to allocate a new player struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>player_new</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name, <span style=color:#66d9ef>addr_t</span> address, <span style=color:#66d9ef>char</span> playerID, <span style=color:#66d9ef>int</span> nRows, <span style=color:#66d9ef>int</span> nColumns, <span style=color:#66d9ef>int</span> startRow, <span style=color:#66d9ef>int</span> startColumn);
</span></span></code></pre></div><p>A function <code>player_setMap</code> to set the player&rsquo;s visibleMap</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>player_setMap</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> map);
</span></span></code></pre></div><p>Function to set player&rsquo;s row</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>player_setRow</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> row);
</span></span></code></pre></div><p>Func to set player&rsquo;s column</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>player_setCol</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> col);
</span></span></code></pre></div><p>A function <code>player_addToPurse</code> to add some gold to a player&rsquo;s purse</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>player_setPurse</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> goldAmount);
</span></span></code></pre></div><p>A function <code>player_getName</code> to get the player&rsquo;s name.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>player_getName</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function <code>player_getMap</code> to get the player&rsquo;s visibleMap</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> <span style=color:#a6e22e>player_getMap</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function <code>player_getID</code> to get the player&rsquo;s playerID</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> <span style=color:#a6e22e>player_getID</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function <code>player_getPoint</code> to get the player&rsquo;s point:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>player_getPoint</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function <code>player_getPurse</code> to get the player&rsquo;s purse:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>player_getPurse</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function <code>player_getAddr</code> to get the player&rsquo;s address</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>addr_t</span> <span style=color:#a6e22e>player_getAddr</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><p>A function <code>player_mapToString</code> to prepare the map to be sent by the server to a client.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>player_mapToString</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player, <span style=color:#66d9ef>int</span> numberOfRows, <span style=color:#66d9ef>int</span> numberOfColumns);
</span></span></code></pre></div><p>A function <code>player_delete</code> to delete an allocated player struct</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>player_delete</span>(<span style=color:#66d9ef>player_t</span><span style=color:#f92672>*</span> player);
</span></span></code></pre></div><h4 id=detailed-pseudo-code-3>Detailed pseudo code<a hidden class=anchor aria-hidden=true href=#detailed-pseudo-code-3>#</a></h4><p><code>player_new</code></p><pre><code>allocate a new player struct
give the player struct the given name, address, starting row &amp; column
allocate player's map based on given row and column sizes
initialize all other values to default
</code></pre><p><code>player_setMap</code></p><pre><code>if the given map and player are not NULL
	set that player's visibleMap to the given map
</code></pre><p><code>player_addToPurse</code></p><pre><code>if the given player is not NULL
	increase that player's purse by specified amount
</code></pre><p><code>player_getMap</code></p><pre><code>if the given player is not NULL
	return that player's map
</code></pre><p><code>player_getPoint</code></p><pre><code>if the given player is not NULL
	return that player's point
</code></pre><p><code>player_getID</code></p><pre><code>if the given player is not NULL
	return that player's playerID
</code></pre><p><code>player_getPurse</code></p><pre><code>if the given player is not NULL
	return that player's purse
</code></pre><p><code>player_getAddr</code></p><pre><code>if the player is not NULL
	return their address
</code></pre><p><code>player_mapToString</code></p><pre><code>allocate a `char*` whose size = (number of rows * (number of cols + 1)) + 1
string_index = 0
for each row
	for each column
		if the point on the player's map is the player's ID
			set the char here in the string to be @
		else
			set the char here in the string to be the char at this point on the map
		increment string_index
	set current string_index to new line char
	increment string_index
set last index in string to be null char
return result char
</code></pre><p><code>player_delete</code></p><pre><code>deallocate player's map
deallocate player struct
</code></pre></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://srbarton43.github.io/>Samuel Barton</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
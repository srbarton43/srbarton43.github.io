<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Midi Controller | Samuel Barton</title>
<meta name=keywords content="Digital Electronics,VHDL"><meta name=description content="A MIDI controller built from scratch on FPGA written in VHDL"><meta name=author content="Samuel Barton & Grant Foley"><link rel=canonical href=https://srbarton43.github.io/projects/midicontroller/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://srbarton43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://srbarton43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://srbarton43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://srbarton43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://srbarton43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://srbarton43.github.io/projects/midicontroller/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Midi Controller"><meta property="og:description" content="A MIDI controller built from scratch on FPGA written in VHDL"><meta property="og:type" content="article"><meta property="og:url" content="https://srbarton43.github.io/projects/midicontroller/"><meta property="og:image" content="https://srbarton43.github.io/projects/midicontroller/cover.jpeg"><meta property="article:section" content="projects"><meta property="article:published_time" content="2024-06-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-09T00:00:00+00:00"><meta property="og:site_name" content="Samuel Barton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://srbarton43.github.io/projects/midicontroller/cover.jpeg"><meta name=twitter:title content="Midi Controller"><meta name=twitter:description content="A MIDI controller built from scratch on FPGA written in VHDL"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://srbarton43.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Midi Controller","item":"https://srbarton43.github.io/projects/midicontroller/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Midi Controller","name":"Midi Controller","description":"A MIDI controller built from scratch on FPGA written in VHDL","keywords":["Digital Electronics","VHDL"],"articleBody":"About For my digital electronics class, my lab partner and I designed an MIDI controller for the Basys3 FPGA board. The FPGA was programed using VHDL. The controller acts as a receiver for the serial MIDI signal coming through over UART and does Direct Digital Synthesis (DDS) to output an analog sine wave. We both learned a lot about digital design and spent many hours debugging on an oscilliscope.\nDemonstration Source Code Link to Repository Design A High-Level Block Diagram of the System\nBefore we even started thinking about writing HDL code for the board, there were many iterations of designs on paper. Here I will go over the design of each subcomponent in the system:\nClock_gen The Clock_Gen component generates a 1 MHz clock signal using the hardware clock which runs at 100 MHz. This system clock frequency was chosen according to the recommended specifications of the PMOD DA2 component. The maximum clock speed for the DA2 is 30 MHz, and the 1 MHz clock fits well into these specifications.\nRTL Block Diagram for the Clock_gen subcomponent\nMIDI_Receiver The MIDI receiver takes the 10-bit serial data from the port MIDI_in, synchronizes it to the specified baud rate, and provides parallel out an 8-bit data_out signal to pipe into the datapath. Internally, it uses a shift register to store each bit serially, and asserts a signal once all the entire MIDI message byte has been received.\nRTL Block Diagram for the MIDI_Receiver component\nDatapath The datapath receives bytes of data from the MIDI receiver one byte at a time, and stores these bytes in specified registers according to their type, whether it be a status byte, pitch byte, or a velocity byte. The datapath processes this data, and passes the necessary information to the DDS and DAC components.\nRTL Block Diagram for the Datapath component\nDDS The Direct Digital Synthesis component converts the m value (derived from the MIDI pitch number) and outputs a sine wave at the correct frequency. The sample rate is approx. 44.1 kHz (de-facto 43.8kHz), typical for cd-quality audio. The sine wave amplitudes are sampled from a BROM lookup table which was provided by Xilinx. A counter which counts by m each time specifies the output frequency (higher m means a higher frequency).\nRTL Block Diagram for the DDS component\nDAC_interface The DAC Interface controls communication from the FPGA to the external PMOD DA2 component. It is a serial peripheral interface (SPI). It consists of a parallel to serial shift register and a controller. The controller asserts CS’ to the external DAC. The specific digital to analog protocol used in this design is 16 bits in big-endian with four leading zeroes.\nRTL Block Diagram for the DAC_interface component\nFinal Report Previous Next / [pdf] View the PDF file here. ","wordCount":"465","inLanguage":"en","image":"https://srbarton43.github.io/projects/midicontroller/cover.jpeg","datePublished":"2024-06-09T00:00:00Z","dateModified":"2024-06-09T00:00:00Z","author":{"@type":"Person","name":"Samuel Barton \u0026 Grant Foley"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://srbarton43.github.io/projects/midicontroller/"},"publisher":{"@type":"Organization","name":"Samuel Barton","logo":{"@type":"ImageObject","url":"https://srbarton43.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://srbarton43.github.io/ accesskey=h title="Samuel Barton (Alt + H)">Samuel Barton</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://srbarton43.github.io/ title=About><span>About</span></a></li><li><a href=https://srbarton43.github.io/projects title=Projects><span>Projects</span></a></li><li><a href=https://srbarton43.github.io/writing title=Writing><span>Writing</span></a></li><li><a href=https://srbarton43.github.io/placeholder title=Resume/CV><span>Resume/CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Midi Controller</h1><div class=post-description>A MIDI controller built from scratch on FPGA written in VHDL</div><div class=post-meta><span title='2024-06-09 00:00:00 +0000 UTC'>June 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Samuel Barton & Grant Foley</div></header><figure class=entry-cover><img loading=eager src=https://srbarton43.github.io/projects/midicontroller/cover.jpeg alt="The FPGA Hooked up to the Testbench"><p>The FPGA Hooked up to the Testbench</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#about aria-label=About>About</a></li><li><a href=#demonstration aria-label=Demonstration>Demonstration</a></li><li><a href=#source-code aria-label="Source Code">Source Code</a></li><li><a href=#design aria-label=Design>Design</a><ul><li><a href=#clock_gen aria-label=Clock_gen>Clock_gen</a></li><li><a href=#midi_receiver aria-label=MIDI_Receiver>MIDI_Receiver</a></li><li><a href=#datapath aria-label=Datapath>Datapath</a></li><li><a href=#dds aria-label=DDS>DDS</a></li><li><a href=#dac_interface aria-label=DAC_interface>DAC_interface</a></li></ul></li><li><a href=#final-report aria-label="Final Report">Final Report</a></li></ul></div></details></div><div class=post-content><h2 id=about>About<a hidden class=anchor aria-hidden=true href=#about>#</a></h2><p>For my digital electronics class, my lab partner and I designed an MIDI controller for the Basys3 FPGA board.
The FPGA was programed using VHDL.
The controller acts as a receiver for the serial MIDI signal coming through over UART and does Direct Digital Synthesis (DDS) to output an analog sine wave.
We both learned a lot about digital design and spent many hours debugging on an oscilliscope.</p><h2 id=demonstration>Demonstration<a hidden class=anchor aria-hidden=true href=#demonstration>#</a></h2><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/UMlpwUrmbk4?rel=0?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><h2 id=source-code>Source Code<a hidden class=anchor aria-hidden=true href=#source-code>#</a></h2><p><a href=https://github.com/srbarton43/midi_controller title="github repo" target=_blank>Link to Repository</a></p><h2 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h2><figure><img loading=lazy src=/projects/midicontroller/highlevel.png alt="A High-Level Block Diagram of the System"><figcaption><p>A High-Level Block Diagram of the System</p></figcaption></figure><p>Before we even started thinking about writing HDL code for the board, there were many iterations of designs on paper.
Here I will go over the design of each subcomponent in the system:</p><h3 id=clock_gen><code>Clock_gen</code><a hidden class=anchor aria-hidden=true href=#clock_gen>#</a></h3><p>The Clock_Gen component generates a 1 MHz clock signal using the hardware clock which runs at 100 MHz.
This system clock frequency was chosen according to the recommended specifications of the PMOD DA2 component.
The maximum clock speed for the DA2 is 30 MHz, and the 1 MHz clock fits well into these specifications.</p><figure><img loading=lazy src=/projects/midicontroller/clockgen.png alt="RTL Block Diagram for the Clock_gen subcomponent"><figcaption><p>RTL Block Diagram for the Clock_gen subcomponent</p></figcaption></figure><h3 id=midi_receiver><code>MIDI_Receiver</code><a hidden class=anchor aria-hidden=true href=#midi_receiver>#</a></h3><p>The MIDI receiver takes the 10-bit serial data from the port MIDI_in, synchronizes it to the specified baud rate, and provides parallel out an 8-bit data_out signal to pipe into the datapath.
Internally, it uses a shift register to store each bit serially, and asserts a signal once all the entire MIDI message byte has been received.</p><figure><img loading=lazy src=/projects/midicontroller/receiver.png alt="RTL Block Diagram for the MIDI_Receiver component"><figcaption><p>RTL Block Diagram for the MIDI_Receiver component</p></figcaption></figure><h3 id=datapath><code>Datapath</code><a hidden class=anchor aria-hidden=true href=#datapath>#</a></h3><p>The datapath receives bytes of data from the MIDI receiver one byte at a time, and stores these bytes in specified registers according to their type, whether it be a status byte, pitch byte, or a velocity byte.
The datapath processes this data, and passes the necessary information to the DDS and DAC components.</p><figure><img loading=lazy src=/projects/midicontroller/datapath.png alt="RTL Block Diagram for the Datapath component"><figcaption><p>RTL Block Diagram for the Datapath component</p></figcaption></figure><h3 id=dds><code>DDS</code><a hidden class=anchor aria-hidden=true href=#dds>#</a></h3><p>The Direct Digital Synthesis component converts the m value (derived from the MIDI pitch number) and outputs a sine wave at the correct frequency.
The sample rate is approx. 44.1 kHz (de-facto 43.8kHz), typical for cd-quality audio.
The sine wave amplitudes are sampled from a BROM lookup table which was provided by Xilinx.
A counter which counts by m each time specifies the output frequency (higher m means a higher frequency).</p><figure><img loading=lazy src=/projects/midicontroller/dds.png alt="RTL Block Diagram for the DDS component"><figcaption><p>RTL Block Diagram for the DDS component</p></figcaption></figure><h3 id=dac_interface><code>DAC_interface</code><a hidden class=anchor aria-hidden=true href=#dac_interface>#</a></h3><p>The DAC Interface controls communication from the FPGA to the external PMOD DA2 component.
It is a serial peripheral interface (SPI).
It consists of a parallel to serial shift register and a controller.
The controller asserts CS’ to the external DAC.
The specific digital to analog protocol used in this design is 16 bits in big-endian with four leading zeroes.</p><figure><img loading=lazy src=/projects/midicontroller/dac.png alt="RTL Block Diagram for the DAC_interface component"><figcaption><p>RTL Block Diagram for the DAC_interface component</p></figcaption></figure><h2 id=final-report>Final Report<a hidden class=anchor aria-hidden=true href=#final-report>#</a></h2><script type=text/javascript src=/js/pdf-js/build/pdf.js></script><style>#embed-pdf-container{position:relative;width:100%;height:auto;min-height:20vh}.pdf-canvas{border:1px solid #000;direction:ltr;width:100%;height:auto;display:none}#the-canvas{border:1px solid #000;direction:ltr;width:100%;height:auto;display:none}.pdf-loadingWrapper{display:none;justify-content:center;align-items:center;width:100%;height:350px}.pdf-loading{display:inline-block;width:50px;height:50px;border:3px solid #d2d0d0;border-radius:50%;border-top-color:#383838;animation:spin 1s ease-in-out infinite;-webkit-animation:spin 1s ease-in-out infinite}#overlayText{word-wrap:break-word;display:grid;justify-content:end}#overlayText a{position:relative;top:10px;right:4px;color:#000;margin:auto;background-color:#eee;padding:.3em 1em;border:solid 2px;border-radius:12px;border-color:#00000030;text-decoration:none}#overlayText svg{height:clamp(1em,2vw,1.4em);width:clamp(1em,2vw,1.4em)}@keyframes spin{to{-webkit-transform:rotate(360deg)}}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}</style><div class=embed-pdf-container id=embed-pdf-container-b93b4cb1><div class=pdf-loadingWrapper id=pdf-loadingWrapper-b93b4cb1><div class=pdf-loading id=pdf-loading-b93b4cb1></div></div><div id=overlayText><a href=/projects/midicontroller/finalreport.pdf aria-label=Download download><svg aria-hidden="true" viewBox="0 0 18 18"><path d="M9 13c.3.0.5-.1.7-.3L15.4 7 14 5.6l-4 4V1H8v8.6l-4-4L2.6 7l5.7 5.7c.2.2.4.3.7.3zm-7 2h14v2H2z"/></svg></a></div><canvas class=pdf-canvas id=pdf-canvas-b93b4cb1></canvas></div><div class=pdf-paginator id=pdf-paginator-b93b4cb1><button id=pdf-prev-b93b4cb1>Previous</button>
<button id=pdf-next-b93b4cb1>Next</button> &nbsp; &nbsp;
<span><span class=pdf-pagenum id=pdf-pagenum-b93b4cb1></span> / <span class=pdf-pagecount id=pdf-pagecount-b93b4cb1></span>
</span><a class=pdf-source id=pdf-source-b93b4cb1 href=/projects/midicontroller/finalreport.pdf>[pdf]</a></div><noscript>View the PDF file <a class=pdf-source id=pdf-source-noscript-b93b4cb1 href=/projects/midicontroller/finalreport.pdf>here</a>.</noscript><script type=text/javascript>(function(){c="/projects/midicontroller/finalreport.pdf",u=""==="true",l=""==="true",h=parseInt("")||1,s=window["pdfjs-dist/build/pdf"],s.GlobalWorkerOptions.workerSrc==""&&(s.GlobalWorkerOptions.workerSrc="https://srbarton43.github.io/js/pdf-js/build/pdf.worker.js");var s,c,l,u,h,n=null,e=h,i=!1,o=null,b=3,t=document.getElementById("pdf-canvas-b93b4cb1"),m=t.getContext("2d"),f=document.getElementById("pdf-paginator-b93b4cb1"),r=document.getElementById("pdf-loadingWrapper-b93b4cb1");v(),g();function a(e){i=!0,n.getPage(e).then(function(e){var s,r,n=e.getViewport({scale:b});t.height=n.height,t.width=n.width,s={canvasContext:m,viewport:n},r=e.render(s),r.promise.then(function(){i=!1,p(),o!==null&&(a(o),o=null)})}),document.getElementById("pdf-pagenum-b93b4cb1").textContent=e}function p(){r.style.display="none",t.style.display="block"}function g(){if(l)return;r.style.display="flex",t.style.display="none"}function v(){if(u)return;f.style.display="block"}function d(e){i?o=e:a(e)}function j(){if(e<=1)return;e--,d(e)}document.getElementById("pdf-prev-b93b4cb1").addEventListener("click",j);function y(){if(e>=n.numPages)return;e++,d(e)}document.getElementById("pdf-next-b93b4cb1").addEventListener("click",y),s.getDocument(c).promise.then(function(t){n=t;var s=n.numPages;document.getElementById("pdf-pagecount-b93b4cb1").textContent=s,e>s&&(e=s),a(e)})})()</script></div><footer class=post-footer><ul class=post-tags><li><a href=https://srbarton43.github.io/tags/digital-electronics/>Digital Electronics</a></li><li><a href=https://srbarton43.github.io/tags/vhdl/>VHDL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://srbarton43.github.io/>Samuel Barton</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
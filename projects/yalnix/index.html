<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Yalnix | Samuel Barton</title>
<meta name=keywords content="operating system,software,c"><meta name=description content="Designed and implemented userspace and kernelspace for a OS written in over 7000 lines of C"><meta name=author content="Samuel Barton & Wyatt Ellison"><link rel=canonical href=https://srbarton43.github.io/projects/yalnix/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://srbarton43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://srbarton43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://srbarton43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://srbarton43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://srbarton43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://srbarton43.github.io/projects/yalnix/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Yalnix"><meta property="og:description" content="Designed and implemented userspace and kernelspace for a OS written in over 7000 lines of C"><meta property="og:type" content="article"><meta property="og:url" content="https://srbarton43.github.io/projects/yalnix/"><meta property="og:image" content="https://srbarton43.github.io/projects/yalnix/cover.png"><meta property="article:section" content="projects"><meta property="article:published_time" content="2024-03-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-09T00:00:00+00:00"><meta property="og:site_name" content="Samuel Barton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://srbarton43.github.io/projects/yalnix/cover.png"><meta name=twitter:title content="Yalnix"><meta name=twitter:description content="Designed and implemented userspace and kernelspace for a OS written in over 7000 lines of C"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://srbarton43.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Yalnix","item":"https://srbarton43.github.io/projects/yalnix/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Yalnix","name":"Yalnix","description":"Designed and implemented userspace and kernelspace for a OS written in over 7000 lines of C","keywords":["operating system","software","c"],"articleBody":"Modules Here we list the various modules in our yalnix implementation… each module has its own header file, and a well-defined API.\nkernel The kernel module stores all code necessary for booting yalnix, and other necessary procedures. The two important functions are KernelStart and SetKernelBrk. KernelStart initializes all important kernel data structures and initializes virtual memory for the system. SetKernelBrk is called each time the kernel must resize its heap, and allocates free frames accordingly.\nkernel_utils The kernel_utils module provides methods to print the user context, the doIdle function, KernelContext switching and copying. It also has a heap checker which we used in debugging, as well as yalnix_xalloc, for memory allocation checkers that would TracePrint and abort if there was an issue allocating memory in the kernel. We also have helper functions to check if an address is in region 1 and if it is readable/writeable by the user, which is used for checking buffer addresses for syscalls.\npagetable The pagetable module stores all functions and routines involving pagetables and pagetable entries (PTEs). The module abstracts all access away from accessing raw PTE elements, so allows writing safer code throughout the program.\nbitvector The bitvector module allows for an abstract representation for tracking free memory frames. Each free frame of memory is represented by a ‘0’ on the bitvector and a ‘1’ means that the frame is mapped to virtual memory. For the machines that we used, there were typically 512 frames of physical memory available, but the size of the bitvector is dynamically determined by bootstrapping inside KernelStart\nlinked_list The linked_list module is an implementation of a linked list data structure and is used throughout Yalnix for creating queues and other lists. It provides several queue-specific functions such as dequeue and peek and is generally used as a FIFO list. We wrapped linked list functions in all other list/queue function calls in other modules so that there was less repetition of code throughout the project, and so that it was easier to isolate bugs to one module.\npcb The pcb module implements the process control block data structure used in our kernel. We initially wrote it to have be its own linked list node, but because we want to keep a linked list of children we decided that each pcb should be its own structure that has pcb_node types pointing to it (so we also implement wrapper functions / structures for pcb_lists off of the linked_list module). The pcb_t struct is transparent to the user, but it also has methods for dealing with pcb lists, dealing with the process’s child list, creating new and retiring processes, and getting processes from queues.\nprog_mgmt The proc_mgmt module contains methods and global structures for process management. The currently running process and process queues are global variables from this module, as well as methods to initialize the Idle and Init PCBs. It also has methods to help with sleeping processes and switching processes. We implemented our round-robin scheduling algorithm in this module, in which the kernel will switch to the first process off the ready queue (or go to idle if there are no processes ready). We also have methods for blocking the current process and unblocking the process (which takes in a flag for if it’s in the blocked queue or stored in another bookkeeping structure, like a pipe, cvar, lock, etc.).\nLoadProgram This module allows for programs specifically compiled for Yalnix to be loaded into kernel memory. The backbone for this module was mostly written for us, but we added specific implementation details such as how we handled pagetables and bookkeeping for PCBs.\ntrap The trap module implements the traps the hardware can throw to Yalnix.\ntrap_clock will decrement the timer on sleeping processes, and then perform a round-robin process switch if there are any ready processes. trap_kernel will, through a switch case, call the syscalls described in the syscalls module. trap_memory will handle access errors and map errors. In the case of an access error, the process will be killed, and in the case of a map error, if the offending address is below the stack and above the red zone, the stack will grow to meet it, otherwise the process will be killed. trap_illegal will kill the current process (user error) trap_math will kill the current process (user error) trap_tty_transmit will unblock the process that is waiting on a given TTY terminal to finish transmitting. trap_tty_receive will receive the bytes from a tty input into the tty buffer (described in tty module) and unblock the process currently waiting to receive input from that terminal (if there is one). If there are more bytes to receive than there is space in the receiving buffer, the buffer will double in size until there is space. (So the tty terminal could fill up the kernel memory if there are enough inputs into the buffer that are not read or flushed by a program). trap_unimplemented will TracePrint at level 1 if the interrupt vector table somehow throws a trap that we can’t handle. syscalls The syscalls module contains code to handle each of the 21 Yalnix syscalls on the kernel end of the OS. Each time a user program calls a syscall, the hardware throws a TRAP_KERNEL and executes one of the syscalls according to the UserContext provided, will call the appropriate kernel syscall handler. Syscalls return integer return codes like -1 for ERROR and 0 for success, but also integer values when reading from / writing to buffers, described in the modules that contain our syscall logic below.\ntty The tty module describes structures and functions for handling tty input and output. There are buffers for tty output (tty_buf) and for input (tty_recv_buf). They both hold a pointer to an allocated buffer, a pointer to the end of the data in the buffer, and the length of the data in the buffer. Additionally, tty_recv_buf holds the size of the allocated buffer so that it can grow if necessary. There are also global arrays of pcbs and buffers for each tty_terminal (send and receive). There’s a tty_init method that KernelStart calls to initialize all the global arrays. When a user calls TtyWrite, the kernel (after trapping and calling the syscall) will allocate a buffer in the kernel, copy the data from the user buffer into the kernel buffer, and then write the maximum number of bytes to the tty terminal until the entire kernel buffer is finished (blocking each time and waiting for the trap_tty_transmit to unblock it), and then the number of bytes written in total will be returned. When a user calls TtyRead, the process will check to see if there are any bytes available in the kernel buffer (and block if there are not, waiting for the trap_tty_receive to unblock it), and then copy either the requested number of bytes or the number of available bytes from the kernel buffer into the user buffer, whichever is lesser, and return that number in the syscall. If the user reads fewer bytes than there are in the buffer, the kernel will shift the buffer to move the next-available bytes to the front of the buffer.\nWe also handle a number of bad / malicious inputs by returning -1 (defined ERROR) from the syscalls. If the TTY_id’s are bad, we return -1. If the buffer length is a negative integer, we return -1. If the user tries to pass in a buffer that is not in region 1, we return -1. TtyWrite is allowed to read from any buffers in user memory that are valid (including user text), because the user should be allowed to read their own text. However, TtyRead is not allowed to write tty input into buffers in user memory because the user should not be allowed to overwrite their own code. We also put a hard cap on how many bytes a buffer can be (in both tty and in pipe) of 0x4000 (defined in include/kernel.h), because we felt that there should be protection in the kernel from a user trying to allocate too big of a buffer for a pipe or tty_terminal. If a user tries to TtyRead or TtyWrite more than 0x4000 bytes in one go, they will get a return code of -1 (and no bytes will be written/read). If a user, through their keyboard / tty input, tries to input enough bytes such that the tty buffer will overflow to be more than 0x4000 bytes, it will stop saving bytes once the size is more than 0x4000. All of this behavior is tested in the test/tty_break.c described in the TESTING_README.md file, with the expectation of this final tty input overflow issue, because we were unable to test reading in so many bytes into the tty terminal using the -In argument. Replicate this by running ./yalnix -lk 3 -I0 test.in -x -W test/ttybreak_serious after creating a file test.in in your directory with more than 17kB of garbage data and see that the kernel aborts because the tty process aborts before our kernel can handle the input.\npipe The pipe module contains all data structures and functions necessary for Yalnix’s three IPC syscalls. Our implementation of pipes are doubly ended, meaning that if a process has a pipe, it can both write and read from it. Pipes are implemented in a similar way as TTY, meaning that the pipe data structures contain a pointer to a dynamically allocated buffer, a pointer to the start of the buffer (which is typically the same as the buffer except temporarily when reading from the pipe). There is also an integer that is the pipe ID and a pointer to a list of PCBs that might be waiting on that pipe. The user must call PipeInit on a pointer to an integer to assign that integer to the correct PipeID (which will always be a multiple of 3, for handling the Reclaim syscall that needs to differentiate pipe, cvar, and lock IDs) and will return 0 for SUCCESS and -1 for ERROR (errors cases described below). A user can write data to the pipe with PipeWrite, which will write the given length of bytes to the kernel buffer from the user buffer, and then return the length written (or ERROR if there is an error growing the pipe buffer, such as if it is more than the max buffer size defined in include/kernel.h, and then it will broadcast to any processes waiting on the pipe to wake up to try to read. A user can read data from the pipe with PipeRead, where it will block if there are no bytes to read (and add to a list of waiting processes), or copy the given or available number (whichever is less) from the kernel buffer to the user buffer, returning that length or ERROR if there are any errors (described below).\nWe also handle a number of bad / malicious inputs by returning -1 (defined ERROR) from the syscalls. If the PipeIDs are bad, we return -1. If the buffer length is a negative integer, we return -1. If the user tries to pass in a buffer that is not in region 1, we return -1. PipeWrite is allowed to read from any buffers in user memory that are valid (including user text), because the user should be allowed to read their own text. However, PipeRead is not allowed to write from the kernel pipe buffer into buffers in user memory because the user should not be allowed to overwrite their own code. We also put a hard cap on how many bytes a buffer can be (in both tty and in pipe) of 0x4000 (defined in include/kernel.h), because we felt that there should be protection in the kernel from a user trying to allocate too big of a buffer for a pipe or tty_terminal. If a user tries to PipeWrite more than 0x4000 bytes in one go, they will get a return code of -1 (and no bytes will be written/read). If a user tries to PipeWrite less than 0x4000 bytes but it will cause the pipe buffer to grow to be more than 0x4000 bytes, it will write the bytes that get it to be right at the max size and return that number of bytes, unless the buffer is exactly full, in which case it will return -1. All of this behavior is tested in the test/pipe_break.c described in the TESTING_README.md file.\nsync_vars The sync_vars module contains functions and data structures for all of the synchronization syscalls in Yalnix. There are both mutexes (lock_t) and conditional variable (cvar_t) data structures implemented in the module. The module also maintains a list of all locks and conditional variables stored in the kernel, and marks them each with a unique ID. We specifically implemented unique IDs between pipes, cvars, and locks based on the fact that we know there only need be three global lists, one for each data structure. Thus, each pipe has an id where pipe_id % 3 = 0, lock has an id where lock_id % 3 = 1, and cvar_id % 3 = 2. We made the specific implementation choice that if a process dies or is killed while holding a lock, it will release said lock. Also we made the design choice that a lock can only be reclaimed by a user program if it is not currently held by any process.\nSpecific Design Choices for Sync Vars\nlock_id % 3 = 1 and cvar_id % 3 = 2 (and pipe_id % 3 = 0) because we wanted Reclaim to be able to tell apart the different IDs when trying to call pipe_delete, etc., so this felt like a solution with the least overhead to be sure that lock, cvar, and pipe IDs are all exclusive. Processes release locks upon death to prevent deadlocks. Furthermore, if a process is queued to acquire the lock but then dies before acquiring it, it is skipped over in the queue for an alive process. Locks can only be reclaimed if they are currently unheld by a process. ","wordCount":"2349","inLanguage":"en","image":"https://srbarton43.github.io/projects/yalnix/cover.png","datePublished":"2024-03-09T00:00:00Z","dateModified":"2024-03-09T00:00:00Z","author":{"@type":"Person","name":"Samuel Barton \u0026 Wyatt Ellison"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://srbarton43.github.io/projects/yalnix/"},"publisher":{"@type":"Organization","name":"Samuel Barton","logo":{"@type":"ImageObject","url":"https://srbarton43.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://srbarton43.github.io/ accesskey=h title="Samuel Barton (Alt + H)">Samuel Barton</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://srbarton43.github.io/ title=About><span>About</span></a></li><li><a href=https://srbarton43.github.io/projects title=Projects><span>Projects</span></a></li><li><a href=https://srbarton43.github.io/writing title=Writing><span>Writing</span></a></li><li><a href=https://srbarton43.github.io/placeholder title=Resume/CV><span>Resume/CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Yalnix</h1><div class=post-description>Designed and implemented userspace and kernelspace for a OS written in over 7000 lines of C</div><div class=post-meta><span title='2024-03-09 00:00:00 +0000 UTC'>March 9, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Samuel Barton & Wyatt Ellison</div></header><figure class=entry-cover><img loading=eager src=https://srbarton43.github.io/projects/yalnix/cover.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#modules aria-label=Modules>Modules</a><ul><li><a href=#kernel aria-label=kernel>kernel</a></li><li><a href=#kernel_utils aria-label=kernel_utils>kernel_utils</a></li><li><a href=#pagetable aria-label=pagetable>pagetable</a></li><li><a href=#bitvector aria-label=bitvector>bitvector</a></li><li><a href=#linked_list aria-label=linked_list>linked_list</a></li><li><a href=#pcb aria-label=pcb>pcb</a></li><li><a href=#prog_mgmt aria-label=prog_mgmt>prog_mgmt</a></li><li><a href=#loadprogram aria-label=LoadProgram>LoadProgram</a></li><li><a href=#trap aria-label=trap>trap</a></li><li><a href=#syscalls aria-label=syscalls>syscalls</a></li><li><a href=#tty aria-label=tty>tty</a></li><li><a href=#pipe aria-label=pipe>pipe</a></li><li><a href=#sync_vars aria-label=sync_vars>sync_vars</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=modules>Modules<a hidden class=anchor aria-hidden=true href=#modules>#</a></h2><p>Here we list the various modules in our yalnix implementation… each module has its own header file, and a well-defined API.</p><h3 id=kernel><code>kernel</code><a hidden class=anchor aria-hidden=true href=#kernel>#</a></h3><p>The <code>kernel</code> module stores all code necessary for booting yalnix, and other necessary procedures.
The two important functions are <code>KernelStart</code> and <code>SetKernelBrk</code>.
<code>KernelStart</code> initializes all important kernel data structures and initializes virtual memory for the system.
<code>SetKernelBrk</code> is called each time the kernel must resize its heap, and allocates free frames accordingly.</p><h3 id=kernel_utils><code>kernel_utils</code><a hidden class=anchor aria-hidden=true href=#kernel_utils>#</a></h3><p>The <code>kernel_utils</code> module provides methods to print the user context, the <code>doIdle</code> function, <code>KernelContext</code> switching and copying.
It also has a heap checker which we used in debugging, as well as <code>yalnix_xalloc</code>, for memory allocation checkers that would TracePrint and abort if there was an issue allocating memory in the kernel.
We also have helper functions to check if an address is in region 1 and if it is readable/writeable by the user, which is used for checking buffer addresses for syscalls.</p><h3 id=pagetable><code>pagetable</code><a hidden class=anchor aria-hidden=true href=#pagetable>#</a></h3><p>The <code>pagetable</code> module stores all functions and routines involving pagetables and pagetable entries (PTEs).
The module abstracts all access away from accessing raw PTE elements, so allows writing safer code throughout the program.</p><h3 id=bitvector><code>bitvector</code><a hidden class=anchor aria-hidden=true href=#bitvector>#</a></h3><p>The <code>bitvector</code> module allows for an abstract representation for tracking free memory frames.
Each free frame of memory is represented by a ‘0’ on the bitvector and a ‘1’ means that the frame is mapped to virtual memory.
For the machines that we used, there were typically 512 frames of physical memory available, but the size of the bitvector is dynamically determined by bootstrapping inside <code>KernelStart</code></p><h3 id=linked_list><code>linked_list</code><a hidden class=anchor aria-hidden=true href=#linked_list>#</a></h3><p>The <code>linked_list</code> module is an implementation of a linked list data structure and is used throughout Yalnix for creating queues and other lists.
It provides several queue-specific functions such as <code>dequeue</code> and <code>peek</code> and is generally used as a FIFO list.
We wrapped linked list functions in all other list/queue function calls in other modules so that there was less repetition of code throughout the project, and so that it was easier to isolate bugs to one module.</p><h3 id=pcb><code>pcb</code><a hidden class=anchor aria-hidden=true href=#pcb>#</a></h3><p>The <code>pcb</code> module implements the process control block data structure used in our kernel.
We initially wrote it to have be its own linked list node, but because we want to keep a linked list of children we decided that each pcb should be its own structure that has <code>pcb_node</code> types pointing to it (so we also implement wrapper functions / structures for <code>pcb_lists</code> off of the <code>linked_list</code> module).
The <code>pcb_t</code> struct is transparent to the user, but it also has methods for dealing with pcb lists, dealing with the process’s child list, creating new and retiring processes, and getting processes from queues.</p><h3 id=prog_mgmt><code>prog_mgmt</code><a hidden class=anchor aria-hidden=true href=#prog_mgmt>#</a></h3><p>The <code>proc_mgmt</code> module contains methods and global structures for process management.
The currently running process and process queues are global variables from this module, as well as methods to initialize the Idle and Init PCBs.
It also has methods to help with sleeping processes and switching processes.
We implemented our round-robin scheduling algorithm in this module, in which the kernel will switch to the first process off the ready queue (or go to idle if there are no processes ready).
We also have methods for blocking the current process and unblocking the process (which takes in a flag for if it’s in the blocked queue or stored in another bookkeeping structure, like a pipe, cvar, lock, etc.).</p><h3 id=loadprogram><code>LoadProgram</code><a hidden class=anchor aria-hidden=true href=#loadprogram>#</a></h3><p>This module allows for programs specifically compiled for Yalnix to be loaded into kernel memory.
The backbone for this module was mostly written for us, but we added specific implementation details such as how we handled pagetables and bookkeeping for PCBs.</p><h3 id=trap><code>trap</code><a hidden class=anchor aria-hidden=true href=#trap>#</a></h3><p>The <code>trap</code> module implements the traps the hardware can throw to Yalnix.</p><ul><li><code>trap_clock</code> will decrement the timer on sleeping processes, and then perform a round-robin process switch if there are any ready processes.</li><li><code>trap_kernel</code> will, through a switch case, call the syscalls described in the <code>syscalls</code> module.</li><li><code>trap_memory</code> will handle access errors and map errors. In the case of an access error, the process will be killed, and in the case of a map error, if the offending address is below the stack and above the red zone, the stack will grow to meet it, otherwise the process will be killed.</li><li><code>trap_illegal</code> will kill the current process (user error)</li><li><code>trap_math</code> will kill the current process (user error)</li><li><code>trap_tty_transmit</code> will unblock the process that is waiting on a given TTY terminal to finish transmitting.</li><li><code>trap_tty_receive</code> will receive the bytes from a tty input into the tty buffer (described in <code>tty</code> module) and unblock the process currently waiting to receive input from that terminal (if there is one). If there are more bytes to receive than there is space in the receiving buffer, the buffer will double in size until there is space. (So the tty terminal could fill up the kernel memory if there are enough inputs into the buffer that are not read or flushed by a program).</li><li><code>trap_unimplemented</code> will TracePrint at level 1 if the interrupt vector table somehow throws a trap that we can’t handle.</li></ul><h3 id=syscalls><code>syscalls</code><a hidden class=anchor aria-hidden=true href=#syscalls>#</a></h3><p>The <code>syscalls</code> module contains code to handle each of the 21 Yalnix syscalls on the kernel end of the OS.
Each time a user program calls a syscall, the hardware throws a <code>TRAP_KERNEL</code> and executes one of the <code>syscalls</code> according to the <code>UserContext</code> provided, will call the appropriate kernel syscall handler.
Syscalls return integer return codes like -1 for ERROR and 0 for success, but also integer values when reading from / writing to buffers, described in the modules that contain our syscall logic below.</p><h3 id=tty><code>tty</code><a hidden class=anchor aria-hidden=true href=#tty>#</a></h3><p>The <code>tty</code> module describes structures and functions for handling tty input and output.
There are buffers for tty output (<code>tty_buf</code>) and for input (<code>tty_recv_buf</code>).
They both hold a pointer to an allocated buffer, a pointer to the end of the data in the buffer, and the length of the data in the buffer.
Additionally, <code>tty_recv_buf</code> holds the size of the allocated buffer so that it can grow if necessary.
There are also global arrays of pcbs and buffers for each tty_terminal (send and receive).
There’s a <code>tty_init</code> method that <code>KernelStart</code> calls to initialize all the global arrays.
When a user calls <code>TtyWrite</code>, the kernel (after trapping and calling the syscall) will allocate a buffer in the kernel, copy the data from the user buffer into the kernel buffer, and then write the maximum number of bytes to the tty terminal until the entire kernel buffer is finished (blocking each time and waiting for the trap_tty_transmit to unblock it), and then the number of bytes written in total will be returned.
When a user calls <code>TtyRead</code>, the process will check to see if there are any bytes available in the kernel buffer (and block if there are not, waiting for the <code>trap_tty_receive</code> to unblock it), and then copy either the requested number of bytes or the number of available bytes from the kernel buffer into the user buffer, whichever is lesser, and return that number in the syscall.
If the user reads fewer bytes than there are in the buffer, the kernel will shift the buffer to move the next-available bytes to the front of the buffer.</p><p>We also handle a number of bad / malicious inputs by returning -1 (defined ERROR) from the syscalls.
If the TTY_id’s are bad, we return -1.
If the buffer length is a negative integer, we return -1.
If the user tries to pass in a buffer that is not in region 1, we return -1.
<code>TtyWrite</code> is allowed to read from any buffers in user memory that are valid (including user text), because the user should be allowed to read their own text.
However, <code>TtyRead</code> is not allowed to write tty input into buffers in user memory because the user should not be allowed to overwrite their own code.
We also put a hard cap on how many bytes a buffer can be (in both <code>tty</code> and in <code>pipe</code>) of 0x4000 (defined in <code>include/kernel.h</code>), because we felt that there should be protection in the kernel from a user trying to allocate too big of a buffer for a pipe or tty_terminal.
If a user tries to <code>TtyRead</code> or <code>TtyWrite</code> more than 0x4000 bytes in one go, they will get a return code of -1 (and no bytes will be written/read).
If a user, through their keyboard / tty input, tries to input enough bytes such that the tty buffer will overflow to be more than 0x4000 bytes, it will stop saving bytes once the size is more than 0x4000.
All of this behavior is tested in the <code>test/tty_break.c</code> described in the <code>TESTING_README.md</code> file, with the expectation of this final tty input overflow issue, because we were unable to test reading in so many bytes into the tty terminal using the <code>-In &lt;filename></code> argument.
Replicate this by running <code>./yalnix -lk 3 -I0 test.in -x -W test/ttybreak_serious</code> after creating a file test.in in your directory with more than 17kB of garbage data and see that the kernel aborts because the tty process aborts before our kernel can handle the input.</p><h3 id=pipe><code>pipe</code><a hidden class=anchor aria-hidden=true href=#pipe>#</a></h3><p>The <code>pipe</code> module contains all data structures and functions necessary for Yalnix’s three IPC syscalls.
Our implementation of pipes are doubly ended, meaning that if a process has a pipe, it can both write and read from it.
Pipes are implemented in a similar way as TTY, meaning that the pipe data structures contain a pointer to a dynamically allocated buffer, a pointer to the start of the buffer (which is typically the same as the buffer except temporarily when reading from the pipe).
There is also an integer that is the pipe ID and a pointer to a list of PCBs that might be waiting on that pipe.
The user must call PipeInit on a pointer to an integer to assign that integer to the correct PipeID (which will always be a multiple of 3, for handling the <code>Reclaim</code> syscall that needs to differentiate pipe, cvar, and lock IDs) and will return 0 for SUCCESS and -1 for ERROR (errors cases described below).
A user can write data to the pipe with <code>PipeWrite</code>, which will write the given length of bytes to the kernel buffer from the user buffer, and then return the length written (or ERROR if there is an error growing the pipe buffer, such as if it is more than the max buffer size defined in <code>include/kernel.h</code>, and then it will broadcast to any processes waiting on the pipe to wake up to try to read.
A user can read data from the pipe with <code>PipeRead</code>, where it will block if there are no bytes to read (and add to a list of waiting processes), or copy the given or available number (whichever is less) from the kernel buffer to the user buffer, returning that length or ERROR if there are any errors (described below).</p><p>We also handle a number of bad / malicious inputs by returning -1 (defined ERROR) from the syscalls.
If the PipeIDs are bad, we return -1.
If the buffer length is a negative integer, we return -1.
If the user tries to pass in a buffer that is not in region 1, we return -1.
<code>PipeWrite</code> is allowed to read from any buffers in user memory that are valid (including user text), because the user should be allowed to read their own text.
However, <code>PipeRead</code> is not allowed to write from the kernel pipe buffer into buffers in user memory because the user should not be allowed to overwrite their own code.
We also put a hard cap on how many bytes a buffer can be (in both <code>tty</code> and in <code>pipe</code>) of 0x4000 (defined in <code>include/kernel.h</code>), because we felt that there should be protection in the kernel from a user trying to allocate too big of a buffer for a pipe or tty_terminal.
If a user tries to <code>PipeWrite</code> more than 0x4000 bytes in one go, they will get a return code of -1 (and no bytes will be written/read).
If a user tries to <code>PipeWrite</code> less than 0x4000 bytes but it will cause the pipe buffer to grow to be more than 0x4000 bytes, it will write the bytes that get it to be right at the max size and return that number of bytes, unless the buffer is exactly full, in which case it will return -1.
All of this behavior is tested in the <code>test/pipe_break.c</code> described in the <code>TESTING_README.md</code> file.</p><h3 id=sync_vars><code>sync_vars</code><a hidden class=anchor aria-hidden=true href=#sync_vars>#</a></h3><p>The <code>sync_vars</code> module contains functions and data structures for all of the synchronization syscalls in Yalnix.
There are both mutexes (<code>lock_t</code>) and conditional variable (<code>cvar_t</code>) data structures implemented in the module.
The module also maintains a list of all locks and conditional variables stored in the kernel, and marks them each with a unique ID.
We specifically implemented unique IDs between pipes, cvars, and locks based on the fact that we know there only need be three global lists, one for each data structure.
Thus, each pipe has an id where <code>pipe_id % 3 = 0</code>, lock has an id where <code>lock_id % 3 = 1</code>, and <code>cvar_id % 3 = 2</code>.
We made the specific implementation choice that if a process dies or is killed while holding a lock, it will release said lock.
Also we made the design choice that a lock can only be reclaimed by a user program if it is not currently held by any process.</p><p>Specific Design Choices for Sync Vars</p><ul><li><code>lock_id % 3 = 1</code> and <code>cvar_id % 3 = 2</code> (and <code>pipe_id % 3 = 0</code>) because we wanted <code>Reclaim</code> to be able to tell apart the different IDs when trying to call <code>pipe_delete</code>, etc., so this felt like a solution with the least overhead to be sure that lock, cvar, and pipe IDs are all exclusive.</li><li>Processes release locks upon death to prevent deadlocks. Furthermore, if a process is queued to acquire the lock but then dies before acquiring it, it is skipped over in the queue for an alive process.</li><li>Locks can only be reclaimed if they are currently unheld by a process.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://srbarton43.github.io/tags/operating-system/>Operating System</a></li><li><a href=https://srbarton43.github.io/tags/software/>Software</a></li><li><a href=https://srbarton43.github.io/tags/c/>C</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://srbarton43.github.io/>Samuel Barton</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>